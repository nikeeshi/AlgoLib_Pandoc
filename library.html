<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Tomoki Imai" />
  <title>Algorithm And Tips For Competitive Programming</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
  <link rel="stylesheet" href="library.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">MathJax.Hub.Queue(["Typeset",MathJax.Hub]);</script>
</head>
<body>
<div id="header">
<h1 class="title">Algorithm And Tips For Competitive Programming</h1>
<h2 class="author">Tomoki Imai</h2>
<h3 class="date">2013</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#テンプレート"><span class="toc-section-number">1</span> テンプレート</a><ul>
<li><a href="#c"><span class="toc-section-number">1.1</span> C++</a></li>
<li><a href="#python"><span class="toc-section-number">1.2</span> Python</a></li>
</ul></li>
<li><a href="#算術型"><span class="toc-section-number">2</span> 算術型</a><ul>
<li><a href="#int"><span class="toc-section-number">2.1</span> int</a></li>
<li><a href="#long-long"><span class="toc-section-number">2.2</span> long long</a><ul>
<li><a href="#ビット演算"><span class="toc-section-number">2.2.1</span> ビット演算</a></li>
</ul></li>
<li><a href="#double"><span class="toc-section-number">2.3</span> double</a></li>
<li><a href="#char"><span class="toc-section-number">2.4</span> char</a></li>
<li><a href="#bool"><span class="toc-section-number">2.5</span> bool</a></li>
<li><a href="#補助関数"><span class="toc-section-number">2.6</span> 補助関数</a></li>
</ul></li>
<li><a href="#入出力"><span class="toc-section-number">3</span> 入出力</a><ul>
<li><a href="#cincout"><span class="toc-section-number">3.1</span> cin,cout</a><ul>
<li><a href="#cin"><span class="toc-section-number">3.1.1</span> cin</a></li>
<li><a href="#cout"><span class="toc-section-number">3.1.2</span> cout</a></li>
</ul></li>
<li><a href="#scanfprintf"><span class="toc-section-number">3.2</span> scanf,printf</a><ul>
<li><a href="#scanf"><span class="toc-section-number">3.2.1</span> scanf</a></li>
<li><a href="#printf"><span class="toc-section-number">3.2.2</span> printf</a></li>
</ul></li>
<li><a href="#高速化"><span class="toc-section-number">3.3</span> 高速化</a></li>
</ul></li>
<li><a href="#stdvector"><span class="toc-section-number">4</span> std::vector</a><ul>
<li><a href="#基本"><span class="toc-section-number">4.1</span> 基本</a></li>
<li><a href="#並び換え"><span class="toc-section-number">4.2</span> 並び換え</a><ul>
<li><a href="#sort"><span class="toc-section-number">4.2.1</span> sort</a></li>
<li><a href="#stable_sort"><span class="toc-section-number">4.2.2</span> stable_sort</a></li>
</ul></li>
<li><a href="#unique"><span class="toc-section-number">4.3</span> unique</a></li>
<li><a href="#rotate"><span class="toc-section-number">4.4</span> rotate</a></li>
<li><a href="#next_permutation"><span class="toc-section-number">4.5</span> next_permutation</a></li>
</ul></li>
<li><a href="#探索"><span class="toc-section-number">5</span> 探索</a><ul>
<li><a href="#全探索"><span class="toc-section-number">5.1</span> 全探索</a></li>
<li><a href="#二分探索"><span class="toc-section-number">5.2</span> 二分探索</a></li>
</ul></li>
<li><a href="#文字列操作"><span class="toc-section-number">6</span> 文字列操作</a><ul>
<li><a href="#stdstring"><span class="toc-section-number">6.1</span> std::string</a><ul>
<li><a href="#部分列"><span class="toc-section-number">6.1.1</span> 部分列</a></li>
<li><a href="#検索"><span class="toc-section-number">6.1.2</span> 検索</a></li>
</ul></li>
<li><a href="#stringstream"><span class="toc-section-number">6.2</span> stringstream</a></li>
<li><a href="#再帰下降構文解析"><span class="toc-section-number">6.3</span> 再帰下降構文解析</a></li>
</ul></li>
<li><a href="#整数論"><span class="toc-section-number">7</span> 整数論</a><ul>
<li><a href="#最大公約数最小公倍数"><span class="toc-section-number">7.1</span> 最大公約数,最小公倍数</a><ul>
<li><a href="#最大公約数"><span class="toc-section-number">7.1.1</span> 最大公約数</a></li>
<li><a href="#最小公倍数"><span class="toc-section-number">7.1.2</span> 最小公倍数</a></li>
</ul></li>
<li><a href="#mod"><span class="toc-section-number">7.2</span> mod</a><ul>
<li><a href="#modの計算式について"><span class="toc-section-number">7.2.1</span> modの計算式について</a></li>
<li><a href="#冪乗のmod"><span class="toc-section-number">7.2.2</span> 冪乗のmod</a></li>
</ul></li>
<li><a href="#素数"><span class="toc-section-number">7.3</span> 素数</a><ul>
<li><a href="#エラトステネスの篩"><span class="toc-section-number">7.3.1</span> エラトステネスの篩</a></li>
<li><a href="#素因数分解"><span class="toc-section-number">7.3.2</span> 素因数分解</a></li>
</ul></li>
<li><a href="#コンビネーション"><span class="toc-section-number">7.4</span> コンビネーション</a><ul>
<li><a href="#コンビネーションの数"><span class="toc-section-number">7.4.1</span> コンビネーションの数</a></li>
<li><a href="#列挙"><span class="toc-section-number">7.4.2</span> 列挙</a></li>
</ul></li>
<li><a href="#確率的なアレ"><span class="toc-section-number">7.5</span> 確率的なアレ</a></li>
<li><a href="#ヨセフス数"><span class="toc-section-number">7.6</span> ヨセフス数</a></li>
<li><a href="#乱数"><span class="toc-section-number">7.7</span> 乱数</a></li>
<li><a href="#基数変換"><span class="toc-section-number">7.8</span> 基数変換</a></li>
</ul></li>
<li><a href="#行列"><span class="toc-section-number">8</span> 行列</a><ul>
<li><a href="#基本要素"><span class="toc-section-number">8.1</span> 基本要素</a></li>
<li><a href="#基本演算"><span class="toc-section-number">8.2</span> 基本演算</a></li>
<li><a href="#基本操作"><span class="toc-section-number">8.3</span> 基本操作</a><ul>
<li><a href="#累乗"><span class="toc-section-number">8.3.1</span> 累乗</a></li>
<li><a href="#表示"><span class="toc-section-number">8.3.2</span> 表示</a></li>
<li><a href="#ベクトルとのかけ算"><span class="toc-section-number">8.3.3</span> ベクトルとのかけ算</a></li>
</ul></li>
<li><a href="#テスト"><span class="toc-section-number">8.4</span> テスト</a></li>
<li><a href="#gauss-jordan"><span class="toc-section-number">8.5</span> Gauss-Jordan</a></li>
</ul></li>
<li><a href="#動的計画法およびそれに似たやつらtodo"><span class="toc-section-number">9</span> 動的計画法およびそれに似たやつら。(TODO)</a><ul>
<li><a href="#lcs"><span class="toc-section-number">9.1</span> LCS</a></li>
<li><a href="#lis"><span class="toc-section-number">9.2</span> LIS</a></li>
<li><a href="#巡回セールスマン問題"><span class="toc-section-number">9.3</span> 巡回セールスマン問題</a></li>
<li><a href="#ナップサック問題"><span class="toc-section-number">9.4</span> ナップサック問題</a></li>
</ul></li>
<li><a href="#データ構造"><span class="toc-section-number">10</span> データ構造</a><ul>
<li><a href="#union-find"><span class="toc-section-number">10.1</span> Union-Find</a></li>
<li><a href="#ヒープ"><span class="toc-section-number">10.2</span> ヒープ</a></li>
<li><a href="#bitset"><span class="toc-section-number">10.3</span> bitset</a></li>
<li><a href="#分数"><span class="toc-section-number">10.4</span> 分数</a></li>
</ul></li>
<li><a href="#グラフ"><span class="toc-section-number">11</span> グラフ</a><ul>
<li><a href="#構成要素"><span class="toc-section-number">11.1</span> 構成要素</a></li>
<li><a href="#ベルマンフォード"><span class="toc-section-number">11.2</span> ベルマンフォード</a></li>
<li><a href="#ダイクストラ"><span class="toc-section-number">11.3</span> ダイクストラ</a></li>
<li><a href="#ワーシャルフロイド"><span class="toc-section-number">11.4</span> ワーシャルフロイド</a></li>
<li><a href="#最小全域木"><span class="toc-section-number">11.5</span> 最小全域木</a></li>
<li><a href="#最大流"><span class="toc-section-number">11.6</span> 最大流</a></li>
<li><a href="#最小費用流"><span class="toc-section-number">11.7</span> 最小費用流</a></li>
</ul></li>
<li><a href="#幾何"><span class="toc-section-number">12</span> 幾何</a></li>
<li><a href="#ゲーム"><span class="toc-section-number">13</span> ゲーム</a><ul>
<li><a href="#nim"><span class="toc-section-number">13.1</span> Nim</a></li>
</ul></li>
<li><a href="#いろんなデータ"><span class="toc-section-number">14</span> いろんなデータ</a><ul>
<li><a href="#階乗"><span class="toc-section-number">14.1</span> 階乗</a></li>
<li><a href="#数単位変換"><span class="toc-section-number">14.2</span> 数単位変換</a></li>
<li><a href="#bit"><span class="toc-section-number">14.3</span> bit</a></li>
<li><a href="#最低限の設定ファイル"><span class="toc-section-number">14.4</span> 最低限の設定ファイル</a><ul>
<li><a href="#vim用"><span class="toc-section-number">14.4.1</span> vim用</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="テンプレート"><a href="#テンプレート"><span class="header-section-number">1</span> テンプレート</a></h1>
<p>各種バッドノウハウを含む。</p>
<h2 id="c"><a href="#c"><span class="header-section-number">1.1</span> C++</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iomanip&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;map&gt;</span>
<span class="ot">#include &lt;set&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;bitset&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;utility&gt;</span>
<span class="ot">#include &lt;numeric&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;functional&gt;</span>
<span class="ot">#include &lt;complex&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>

<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define all(c) c.begin(),c.end()</span>
<span class="ot">#define rep(i,n) for(int i=0;i&lt;(int)n;i++)</span>
<span class="ot">#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; &quot; (L&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; endl</span>

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;
<span class="kw">typedef</span> complex&lt;<span class="dt">double</span>&gt; point;
<span class="kw">typedef</span> vector&lt;<span class="dt">int</span>&gt; vi;

<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="kw">inline</span> <span class="dt">int</span> len(<span class="dt">const</span> T&amp; t){
    <span class="kw">return</span> t.size();
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; os,<span class="dt">const</span> vector&lt;T&gt;&amp; val){
    os &lt;&lt; <span class="st">&quot;[ &quot;</span>;
    <span class="kw">for</span>(<span class="kw">typename</span> vector&lt;T&gt;::const_iterator it=val.begin();
        it != val.end();++it){
        os &lt;&lt; *it &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    os &lt;&lt; <span class="st">&quot;]&quot;</span>;
    <span class="kw">return</span> os;
}

<span class="dt">int</span> main(){
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="python"><a href="#python"><span class="header-section-number">1.2</span> Python</a></h2>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>
<span class="co">#coding:utf-8</span>

<span class="ch">from</span> <span class="dt">__future__</span> <span class="ch">import</span> division
<span class="ch">from</span> <span class="dt">__future__</span> <span class="ch">import</span> print_function
<span class="ch">from</span> <span class="dt">__future__</span> <span class="ch">import</span> unicode_literals

<span class="ch">from</span> math <span class="ch">import</span> *
<span class="ch">from</span> string <span class="ch">import</span> *
<span class="ch">from</span> fractions <span class="ch">import</span> *
<span class="ch">from</span> itertools <span class="ch">import</span> *

<span class="kw">def</span> main():
    <span class="kw">pass</span>

<span class="kw">if</span> <span class="dt">__name__</span> == <span class="st">&quot;__main__&quot;</span>:
    main()</code></pre>
<h1 id="算術型"><a href="#算術型"><span class="header-section-number">2</span> 算術型</a></h1>
<h2 id="int"><a href="#int"><span class="header-section-number">2.1</span> int</a></h2>
<p>基本中の基本。<span class="math">\(10^{9}\)</span>くらい。こわいときにはlong longを使うことを推奨。</p>
<h2 id="long-long"><a href="#long-long"><span class="header-section-number">2.2</span> long long</a></h2>
<p>大きい整数。<span class="math">\(10^{18}\)</span>?くらい。</p>
<h3 id="ビット演算"><a href="#ビット演算"><span class="header-section-number">2.2.1</span> ビット演算</a></h3>
<p>ビットDPとかに使う。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 立ってるbitの数を数える</span>
<span class="dt">int</span> popcount(ll x){
    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="kw">while</span>(x){
        x &amp;= x<span class="dv">-1</span>;
        ret++;
    }
    <span class="kw">return</span> ret;
}
<span class="co">// 下から2番目のビットを立てる。1llと書くことに注意</span>
x |= (1ll &lt;&lt; <span class="dv">1</span>);

<span class="co">// 集合演算</span>
<span class="co">// 和</span>
ll z = x | y;
<span class="co">// 積</span>
ll z = x &amp; y;
<span class="co">// xor</span>
ll z = x ^ y;
<span class="co">// ループ</span>
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
    <span class="co">// i番目が立っていれば</span>
    <span class="kw">if</span>(x &amp; (1ll &lt;&lt; i)){
        <span class="co">//something.</span>
    }
}

ll dp[<span class="dv">1</span> &lt;&lt; N][N];
dp[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
<span class="co">// Bitのほうが先!</span>
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;(<span class="dv">1</span>&lt;&lt;N);i++){
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;N;j++){
        <span class="co">//something.</span>
    }
}</code></pre>
<h2 id="double"><a href="#double"><span class="header-section-number">2.3</span> double</a></h2>
<p>floatは使ってはだめ。</p>
<h2 id="char"><a href="#char"><span class="header-section-number">2.4</span> char</a></h2>
<p>-128 ~ 127くらい。ちいさい。基本的には文字を入れるのに使う。vector&lt;char&gt;を vector&lt;bool&gt;の代わりに使ってもいい。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> c = &#39;a&#39;;
<span class="co">//cctypeが必要。大文字に変換する。すでに大文字のときは何も起こらない。</span>
c = toupper(c);
<span class="co">//小文字に変換する。</span>
c = tolower(c);
<span class="co">//vector&lt;bool&gt;の代わり。</span>
vector&lt;<span class="dt">char</span>&gt; used(<span class="dv">10</span>,<span class="kw">false</span>);</code></pre>
<h2 id="bool"><a href="#bool"><span class="header-section-number">2.5</span> bool</a></h2>
<p>true(==1)とかfalse(==0)を入れるためだけに使う。ただしvector&lt;bool&gt;は使ってはいけない。</p>
<h2 id="補助関数"><a href="#補助関数"><span class="header-section-number">2.6</span> 補助関数</a></h2>
<p>上記の型に関する便利な関数。</p>
<p>床関数、天井関数、および四捨五入。返り値はdouble。cmathをincludeする。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> x = <span class="fl">0.3</span>;
<span class="dt">int</span> f = floor(x); <span class="co">// -&gt; 0</span>
<span class="dt">int</span> c = ceil(x); <span class="co">// -&gt; 1</span>
<span class="dt">int</span> r = round(x) <span class="co">// -&gt; 0</span></code></pre>
<p>任意の場所で四捨五入したいときには、<span class="math">\(10^{n}\)</span>をかけて、roundした後に、 <span class="math">\(10^{n}\)</span>で割ればいい。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> x = <span class="fl">0.123456789</span>;
<span class="co">//0.123</span>
<span class="dt">double</span> r = round(x*<span class="dv">1000</span>) / <span class="fl">1000.0</span>;</code></pre>
<h1 id="入出力"><a href="#入出力"><span class="header-section-number">3</span> 入出力</a></h1>
<p>基本はcin,coutを使おう。</p>
<h2 id="cincout"><a href="#cincout"><span class="header-section-number">3.1</span> cin,cout</a></h2>
<p>iostream,iomanipをincludeしておくこと。</p>
<h3 id="cin"><a href="#cin"><span class="header-section-number">3.1.1</span> cin</a></h3>
<p>基本的な使い方について。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;
cin &gt;&gt; n;
vector&lt;<span class="dt">int</span>&gt; V(n);
rep(i,n) cin &gt;&gt; V[i];</code></pre>
<p>こうすると、短く書ける。</p>
<p>入力の最後まで読む。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;
<span class="kw">while</span>(cin &gt;&gt; n){
    <span class="co">//処理</span>
}</code></pre>
<p>n=0のとき終わりとかの場合は、条件に&amp;&amp;n!=0とかをつける。</p>
<p>数値をカンマ区切りで読み込む。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x,y;<span class="dt">char</span> c;
<span class="co">//cにカンマが入る</span>
cin &gt;&gt; x &gt;&gt; c &gt;&gt; y;</code></pre>
<p>冗長かもだけど、一番楽。</p>
<p>空白とか含めて一行読む。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">string s;
getline(cin,s);</code></pre>
<p>改行文字は、sに入らず、かつ読み捨てされる。 cinでは、改行文字は読み捨てないことに注意しよう。 つまり、数値&lt;改行&gt;文字列&lt;改行&gt;を読みたいときには、</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;string s;
<span class="co">// 数値</span>
cin &gt;&gt; n;
<span class="co">// 改行よみとばし</span>
cin.ignore();
<span class="co">// 文字列</span>
getline(cin,s);</code></pre>
<p>とする。cinは改行文字を残すので、ignoreでそれを読み捨てないといけない。 また、ignoreの引数は読み捨てる文字数。引数なしの場合は1を渡したのと同等 の効果がある。</p>
<h3 id="cout"><a href="#cout"><span class="header-section-number">3.1.2</span> cout</a></h3>
<p>有効数字等が設定されている問題は、必ず多めに出力すること。多めに出す分に は大丈夫。</p>
<p>基本の使い方</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;vector&lt;<span class="dt">int</span>&gt; V(n);
cout &lt;&lt; n &lt;&lt; endl;
rep(i,n) cout &lt;&lt; V[i] &lt;&lt; <span class="st">&quot; &quot;</span>;
cout &lt;&lt; endl;</code></pre>
<p>以下主なiomanipの使い方</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n = <span class="dv">123</span>;<span class="dt">double</span> d = <span class="fl">1.23</span>;

<span class="co">//10進数 −&gt; 123</span>
cout &lt;&lt; dec &lt;&lt; n &lt;&lt; endl ;

<span class="co">//8進数 −&gt; 173</span>
cout &lt;&lt; oct &lt;&lt; n &lt;&lt; endl ;

<span class="co">//16進数 −&gt; 7b</span>
cout &lt;&lt; hex &lt;&lt; n &lt;&lt; endl ;

<span class="co">//16進数かつ、大文字 −&gt; 7B</span>
cout &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; n &lt;&lt; endl;

<span class="co">//10進数に戻す</span>
cout &lt;&lt; dec;

<span class="co">//幅が10になるようにする。デフォルトは右寄せ</span>
<span class="co">// -&gt; xxxxxxx123 (default)</span>
cout &lt;&lt; setfill(&#39;x&#39;) &lt;&lt; setw(<span class="dv">10</span>) &lt;&lt; right &lt;&lt; n &lt;&lt; endl;

<span class="co">// -&gt; 123xxxxxxx</span>
cout &lt;&lt; setfill(&#39;x&#39;) &lt;&lt; setw(<span class="dv">10</span>) &lt;&lt; left &lt;&lt; n &lt;&lt; endl;
<span class="co">// -&gt; 123yyyyyyy</span>
cout &lt;&lt; setfill(&#39;y&#39;) &lt;&lt; setw(<span class="dv">10</span>) &lt;&lt; n &lt;&lt; endl;

<span class="co">//小数点以下10桁表示に。</span>
cout &lt;&lt; fixed &lt;&lt; setprecision(<span class="dv">10</span>);

<span class="co">// -&gt; 1.2300000000</span>
cout &lt;&lt; d &lt;&lt; endl;
<span class="co">// -&gt; 12.3000000000</span>
cout &lt;&lt; <span class="dv">10</span>*d &lt;&lt; endl;

<span class="co">//小数点の表示を元に戻す</span>
std.unsetf(ios::fixed);
<span class="co">// -&gt; 1.23</span>
cout &lt;&lt; d &lt;&lt; endl;</code></pre>
<p>基本的には、引数のあるマニピュレータの効果は保存される。</p>
<h2 id="scanfprintf"><a href="#scanfprintf"><span class="header-section-number">3.2</span> scanf,printf</a></h2>
<p>C++では、cstdioをinclude。複雑な書式とかが必要なときにはこっちを使うといいかもしれない。</p>
<h3 id="scanf"><a href="#scanf"><span class="header-section-number">3.2.1</span> scanf</a></h3>
<p>基本的な使い方</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;<span class="dt">char</span> tmp[<span class="dv">256</span>];
scanf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>,&amp;n);
gets(tmp);</code></pre>
<p>stringに直接いれるのはだめ。scanfはcinと同様に改行を残す。getlineするな らcin.ignore。getsするなら、直前のscanfで改行を読んでおく必要がある。 また、scanfで改行を読むのでなく、直後にgetc(stdin)してもいい。</p>
<h3 id="printf"><a href="#printf"><span class="header-section-number">3.2.2</span> printf</a></h3>
<p>基本的な使い方</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n = <span class="dv">100</span>;
printf(<span class="st">&quot;n is %d</span><span class="ch">\n</span><span class="st">&quot;</span>,n);</code></pre>
<p>scanfとほとんど同様の使い方ができる。</p>
<table>
<caption>書式指定子</caption>
<thead>
<tr class="header">
<th align="left">指定子</th>
<th align="left">出力書式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">%c</td>
<td align="left">文字</td>
</tr>
<tr class="even">
<td align="left">%s</td>
<td align="left">文字列</td>
</tr>
<tr class="odd">
<td align="left">%d</td>
<td align="left">符号付き１０進整数</td>
</tr>
<tr class="even">
<td align="left">%u</td>
<td align="left">符号なし10進</td>
</tr>
<tr class="odd">
<td align="left">%f</td>
<td align="left">10進浮動小数点数</td>
</tr>
<tr class="even">
<td align="left">%o</td>
<td align="left">符号なし8進</td>
</tr>
<tr class="odd">
<td align="left">%x</td>
<td align="left">符号なし16進(Xなら大文字)</td>
</tr>
<tr class="even">
<td align="left">%%</td>
<td align="left">%記号</td>
</tr>
</tbody>
</table>
<h2 id="高速化"><a href="#高速化"><span class="header-section-number">3.3</span> 高速化</a></h2>
<p>以下のコードをmain関数の最初に書くことで、cin,coutの速度が2倍程度になる。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ios::sync_with_stdio(<span class="kw">false</span>);
cin.tie(<span class="dv">0</span>);</code></pre>
<p>ただし、このコードはstdioとの同期を切るという意味なので、これを使うとき にはprintfやscanfを使用してはだめ。</p>
<h1 id="stdvector"><a href="#stdvector"><span class="header-section-number">4</span> std::vector</a></h1>
<p>ここでは、配列のSTL版である、vectorの使いかたについて書く。 ここに書かれている関数は、string等にも用いることができるものが多い。 ちなみに、vector&lt;bool&gt;は使ってはいけない。bitsetや、vector&lt;char&gt;をつかうこと。 また、all(vector)は、vector.begin(),vector.end()とdefineしている。</p>
<h2 id="基本"><a href="#基本"><span class="header-section-number">4.1</span> 基本</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//要素数10で、初期値は-1にする。</span>
vector&lt;<span class="dt">int</span>&gt; vec(<span class="dv">10</span>,-<span class="dv">1</span>);
<span class="co">//vecの最初から3つの要素をコピーする。</span>
vector&lt;<span class="dt">int</span>&gt; newvec(vec.begin(),vec.begin()+<span class="dv">3</span>);
<span class="co">//vecの最初から3つの要素を削除する。</span>
vec.erase(vec.begin(),vec.begin()+<span class="dv">3</span>);</code></pre>
<h2 id="並び換え"><a href="#並び換え"><span class="header-section-number">4.2</span> 並び換え</a></h2>
<h3 id="sort"><a href="#sort"><span class="header-section-number">4.2.1</span> sort</a></h3>
<p>C++のsortは、<span class="math">\(O(n \log n)\)</span>で、introsort。何も指定しない場合には昇順にソートされる。 注意すべきなのは、C++11では、最悪ケースで<span class="math">\(O(n \log n)\)</span>となること。C++03では特に何も制限はないが、g++ならば<span class="math">\(O(n \log n)\)</span>である。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//昇順 (sort(vec.begin(),vec.end())) (2,1,3) -&gt; (1,2,3)</span>
sort(all(vec));
<span class="co">//降順 (ただ単純にreverseしてもいい) (2,1,3) -&gt; (3,2,1)</span>
sort(all(vec),greater&lt;<span class="dt">int</span>&gt;());</code></pre>
<p>第三引数には関数を渡すことができる。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> comp(<span class="dt">const</span> <span class="dt">int</span>&amp; a ,<span class="dt">const</span> <span class="dt">int</span>&amp; b){
    <span class="kw">return</span> abs(a) &lt; abs(b);
}
<span class="dt">int</span> main(){
    vector&lt;<span class="dt">int</span>&gt; vec(<span class="dv">10</span>);
    <span class="co">//絶対値が小さい順にソート</span>
    sort(all(vec),comp);
}</code></pre>
<h3 id="stable_sort"><a href="#stable_sort"><span class="header-section-number">4.2.2</span> stable_sort</a></h3>
<p>sortとちがって、同じ優先順位の要素の順番は保存される。最悪計算量は<span class="math">\(O(n \log ^ 2 n)\)</span>である。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">stable_sort(all(vec),comp);</code></pre>
<h2 id="unique"><a href="#unique"><span class="header-section-number">4.3</span> unique</a></h2>
<p>隣あう同じ要素を一つにまとめる。eraseすることに注意。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> ints[] = {<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>};
vector&lt;<span class="dt">int</span>&gt; vec(ints,ints<span class="dv">+5</span>);
vec.erase(unique(all(vec)),vec.end());
<span class="co">// 1 2 1</span>
rep(i,vec.size()) cout &lt;&lt; vec[i] &lt;&lt; endl;</code></pre>
<h2 id="rotate"><a href="#rotate"><span class="header-section-number">4.4</span> rotate</a></h2>
<p>rotateは第二引数の場所を先頭にするように回転する。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>[] ints = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>};
vector&lt;<span class="dt">int</span>&gt; vec(ints,ints<span class="dv">+5</span>);
rotate(vec.begin(),vec.begin()+<span class="dv">1</span>),vec.end()); <span class="co">//2,3,4,5,1</span>
rotate(vec.begin(),vec.end()-<span class="dv">1</span>,vec.end()); <span class="co">//5,1,2,3,4</span></code></pre>
<h2 id="next_permutation"><a href="#next_permutation"><span class="header-section-number">4.5</span> next_permutation</a></h2>
<p>順列をすべて列挙する。<span class="math">\(N!\)</span>個なので、それなりの勢いで大きくなる。章末の付録参照。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; V = {<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>};
<span class="co">//ソートすること。</span>
sort(all(V));

<span class="kw">do</span>{
   <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;V.size();i++){
       cout &lt;&lt; V[i] &lt;&lt; <span class="st">&quot; &quot;</span>;
   }
   cout &lt;&lt; endl;
}<span class="kw">while</span>(next_permutation(all(V)));</code></pre>
<h1 id="探索"><a href="#探索"><span class="header-section-number">5</span> 探索</a></h1>
<h2 id="全探索"><a href="#全探索"><span class="header-section-number">5.1</span> 全探索</a></h2>
<p>全部しらべる。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> linear_search(vector&lt;<span class="dt">int</span>&gt; V,<span class="dt">int</span> val){
    rep(i,V.size()){
        <span class="kw">if</span>(V[i] == val) <span class="kw">return</span> i;
    }
    <span class="kw">return</span> -<span class="dv">1</span>;
}</code></pre>
<h2 id="二分探索"><a href="#二分探索"><span class="header-section-number">5.2</span> 二分探索</a></h2>
<p>ある条件を満たす最小のものを探す。ただし単調増加な物にしかつかえない。 叙述関数をPとすると、</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> lower = <span class="dv">0</span>,upper = <span class="dv">1000000</span>;
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">200</span>;i++){
    <span class="dt">double</span> m = (lower+upper) / <span class="dv">2</span>;
    <span class="kw">if</span>(P(m)){
        upper = m;
    }<span class="kw">else</span>{
        lower = m;
    }
}</code></pre>
<p>とすると、upperに求めたい値がはいる。もしみつからなかった場合には、値は 変わらない。なので、lower,upperには極端な値を設定すること。200という回数 は、すこし多め。100で十分。対象がvectorの場合は以下のように書ける。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main(){
    vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>};
    <span class="co">// ソートする必要あり。</span>
    <span class="co">//  i  0 1 2 3 4 5 6 7 8</span>
    <span class="co">// -&gt; [1,1,1,2,2,2,3,3,3]</span>
    sort(v.begin(),v.end());
    <span class="co">// 2以上の数値が初めて現れる場所 -&gt; 3</span>
    <span class="dt">int</span> lower = lower_bound(v.begin(),v.end(),<span class="dv">2</span>) - v.begin();
    <span class="co">// 2より大きい数値が初めて表われる場所 -&gt; 6</span>
    <span class="dt">int</span> upper = upper_bound(v.begin(),v.end(),<span class="dv">2</span>) - v.begin();
    <span class="co">// 2の個数</span>
    <span class="dt">int</span> number_of_2 = upper - lower;
}</code></pre>
<h1 id="文字列操作"><a href="#文字列操作"><span class="header-section-number">6</span> 文字列操作</a></h1>
<p>stringをincludeする。cctypeもいるかも。</p>
<h2 id="stdstring"><a href="#stdstring"><span class="header-section-number">6.1</span> std::string</a></h2>
<p>charをラップしたテンプレートクラス。 基本的な使い方について</p>
<h3 id="部分列"><a href="#部分列"><span class="header-section-number">6.1.1</span> 部分列</a></h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp">          <span class="co">//0123456789</span>
string str(<span class="st">&quot;abcdefghij&quot;</span>);
<span class="co">// 5番目以降</span>
str.substr(<span class="dv">5</span>);    <span class="co">// &quot;fghij&quot;</span>
<span class="co">// 5番目から3つ</span>
str.substr(<span class="dv">5</span>,<span class="dv">3</span>); <span class="co">// &quot;fgh&quot;</span>
<span class="co">//全部小文字にする</span>
transform(s.begin(),s.end(),s.begin(),::tolower);</code></pre>
<p>substrは一つの引数でそこから先全部、二つの場合は第一引数の位置から、第二 引数の数だけ持ってくる。</p>
<h3 id="検索"><a href="#検索"><span class="header-section-number">6.1.2</span> 検索</a></h3>
<p>stringには、いくつかのfindが定義されている。線形検索なので、早い検索が必 要なときには後述するKMP法やBM法を用いること。</p>
<ul>
<li><p>find 引数が最初に現れる位置</p></li>
<li><p>rfind 引数が最後に表われる位置</p></li>
<li><p>find_first_of 引数の文字のどれかが最初に表われる位置</p></li>
<li><p>find_last_of 引数の文字のどれかが最後に表われる位置</p></li>
<li><p>find_first_not_of 引数の文字のどれかではない文字が最初に表われる位置</p></li>
<li><p>find_first_not_of 引数の文字のどれかではない文字が最後に表われる位置</p></li>
</ul>
<p>第二引数として探すための最初の位置を指定できる。</p>
<h4 id="boyer-moore法"><a href="#boyer-moore法"><span class="header-section-number">6.1.2.1</span> Boyer Moore法</a></h4>
<h4 id="kmp法"><a href="#kmp法"><span class="header-section-number">6.1.2.2</span> KMP法</a></h4>
<h2 id="stringstream"><a href="#stringstream"><span class="header-section-number">6.2</span> stringstream</a></h2>
<p>cinやcoutのようなstreamをstringを元に作成したりする。基本的には、string をフォーマットしたり、intやlongに、intやlongから変換するために使用する。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">stringstream ss;
ss &lt;&lt; <span class="dv">102</span>;
string s;
ss &gt;&gt; s;</code></pre>
<h2 id="再帰下降構文解析"><a href="#再帰下降構文解析"><span class="header-section-number">6.3</span> 再帰下降構文解析</a></h2>
<p>BNFを書いて、それにしたがっていく。左再帰除去を忘れずに。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> string::const_iterator Cursor;
<span class="kw">class</span> ParseError{};

<span class="co">// &lt;四則演算の式&gt; ::= &lt;乗算除算の式&gt; (+ or -) &lt;乗算除算の式&gt; (+ or -) ...</span>
<span class="co">// &lt;乗算除算の式&gt; ::= &lt;括弧か数&gt; (* or /) &lt;括弧か数&gt; (* or /) ...</span>
<span class="co">// &lt;括弧か数&gt;     ::= &#39;(&#39; &lt;四則演算の式&gt; &#39;)&#39; or &lt;数&gt;</span>
<span class="co">// &lt;数&gt;           ::= (0|1|2|3|4|5|6|7|8|9)+</span>

<span class="dt">int</span> expression(Cursor&amp;);
<span class="dt">int</span> term(Cursor&amp;);
<span class="dt">int</span> factor(Cursor&amp;);
<span class="dt">int</span> number(Cursor&amp;);

<span class="co">// &lt;四則演算の式&gt; ::= &lt;乗算除算の式&gt; (+ or -) &lt;乗算除算の式&gt; (+ or -) ...</span>
<span class="dt">int</span> expression(Cursor &amp;c){
    <span class="dt">int</span> ret = term(c);
    <span class="kw">while</span>(*c == &#39;+&#39; <span class="kw">or</span> *c == &#39;-&#39;){
        <span class="kw">if</span>(*c == &#39;+&#39;){
            c++;
            ret += term(c);
        }<span class="kw">else</span>{
            c++;
            ret -= term(c);
        }
    }
    <span class="kw">return</span> ret;
}

<span class="co">// &lt;乗算除算の式&gt; ::= &lt;括弧か数&gt; (* or /) &lt;括弧か数&gt; (* or /) ...</span>
<span class="dt">int</span> term(Cursor &amp;c){
    <span class="dt">int</span> ret = factor(c);
    <span class="kw">while</span>(*c == &#39;*&#39; <span class="kw">or</span> *c == &#39;/&#39;){
        <span class="kw">if</span>(*c == &#39;*&#39;){
            c++;
            ret *= factor(c);
        }<span class="kw">else</span>{
            c++;
            ret /= factor(c);
        }
    }
    <span class="kw">return</span> ret;
}

<span class="co">// &lt;括弧か数&gt;     ::= &#39;(&#39; &lt;四則演算の式&gt; &#39;)&#39; or &lt;数&gt;</span>
<span class="dt">int</span> factor(Cursor &amp;c){
    <span class="kw">if</span>(*c == &#39;(&#39;){
        c++;
        <span class="dt">int</span> ret = expression(c);
        c++; <span class="co">// &#39;)&#39;</span>
        <span class="kw">return</span> ret;
    }<span class="kw">else</span>{
        <span class="kw">return</span> number(c);
    }
}

<span class="co">// &lt;数&gt;           ::= (0|1|2|3|4|5|6|7|8|9)+</span>
<span class="dt">int</span> number(Cursor &amp;c){
    stringstream ss;
    <span class="kw">while</span>(isdigit(*c)){
        ss &lt;&lt; *c;
        c++;
    }
    <span class="dt">int</span> ret;
    ss &gt;&gt; ret;
    <span class="kw">return</span> ret;
}

<span class="dt">int</span> main(){
    <span class="dt">int</span> test_case;
    cin &gt;&gt; test_case;
    cin.ignore();
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;test_case;i++){
        string s;
        getline(cin,s);
        Cursor c = s.begin();
        cout &lt;&lt; expression(c) &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h1 id="整数論"><a href="#整数論"><span class="header-section-number">7</span> 整数論</a></h1>
<h2 id="最大公約数最小公倍数"><a href="#最大公約数最小公倍数"><span class="header-section-number">7.1</span> 最大公約数,最小公倍数</a></h2>
<p>ユークリッドの互除法を使う。intをlong longに置換してもいい。 <span class="math">\(O(\log n)\)</span></p>
<h3 id="最大公約数"><a href="#最大公約数"><span class="header-section-number">7.1.1</span> 最大公約数</a></h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> gcd(<span class="dt">int</span> a,<span class="dt">int</span> b){
    <span class="kw">return</span> b==<span class="dv">0</span> ? a : gcd(b,a%b);
}</code></pre>
<h3 id="最小公倍数"><a href="#最小公倍数"><span class="header-section-number">7.1.2</span> 最小公倍数</a></h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> lcm(<span class="dt">int</span> a,<span class="dt">int</span> b){
    <span class="kw">return</span> a*b / gcd(a,b);
}</code></pre>
<h2 id="mod"><a href="#mod"><span class="header-section-number">7.2</span> mod</a></h2>
<p>long longに入らないような答えのときにmodが登場する。</p>
<h3 id="modの計算式について"><a href="#modの計算式について"><span class="header-section-number">7.2.1</span> modの計算式について</a></h3>
<p><span class="math">\[\begin{aligned}
a \equiv c &amp; \pmod m \\
b \equiv d &amp; \pmod m\end{aligned}\]</span></p>
<p>の条件下では以下の式が成り立つ。</p>
<p><span class="math">\[\begin{aligned}
a+b \equiv c+d  &amp; \pmod m \\
a-b \equiv c-d  &amp; \pmod m \\
a \times b \equiv c \times d  &amp; \pmod m\end{aligned}\]</span></p>
<p>さらに、mが素数の場合、以下の関係が成り立つ。</p>
<p><span class="math">\[\begin{aligned}
a ^ m \equiv a \pmod m \\
a ^ {m-1} \equiv 1 \pmod m \\
a ^ {m-2} \equiv \frac{1}{a} \pmod m\end{aligned}\]</span></p>
<p>つまり、<span class="math">\(a\)</span>で割ることと、<span class="math">\(a^{m-2}\)</span>を掛けることは同じである。<br />これは、<span class="math">\(C(10000,5000) \pmod p\)</span>といった式を計算する際、次の冪乗の演算と組みあわせて用いる。</p>
<h3 id="冪乗のmod"><a href="#冪乗のmod"><span class="header-section-number">7.2.2</span> 冪乗のmod</a></h3>
<p>いわゆるmod_pow。計算量は<span class="math">\(O(\log n)\)</span>。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ll mod_pow(ll x,ll n,ll mod){
    <span class="kw">if</span>(n==<span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    ll ret = mod_pow(x * x % mod,n/<span class="dv">2</span>,mod);
    <span class="kw">if</span>(n%<span class="dv">2</span>== <span class="dv">1</span>)  ret = ret * x % mod;
    <span class="kw">return</span> ret;
}</code></pre>
<p>ちなみにC++のpowを使うときに、引数が整数で、返り値も整数であることを期待 するときには、上記のpowを使うべき。なぜならC++のpowは double,double-&gt;doubleな関数であるから。</p>
<h2 id="素数"><a href="#素数"><span class="header-section-number">7.3</span> 素数</a></h2>
<h3 id="エラトステネスの篩"><a href="#エラトステネスの篩"><span class="header-section-number">7.3.1</span> エラトステネスの篩</a></h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">//上限より余裕を取ること。</span>

vector&lt;<span class="dt">bool</span>&gt; sieve(<span class="dt">const</span> <span class="dt">int</span> M){
    vector&lt;<span class="dt">bool</span>&gt; isPrime(M);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;M;i++) isPrime[i] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i*i &lt; M;i++){
        <span class="kw">if</span>(<span class="kw">not</span> isPrime[i]) <span class="kw">continue</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=i*i;j&lt;M;j+=i){
            isPrime[j] = <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> isPrime;
}</code></pre>
<pre class="py"><code>from math import *

def sieve(N):
    primes = set()
    for i in range(2,N):
        primes.add(i)

    for i in range(2,ceil(sqrt(N))):
        if i in primes:
            for j in range(i*i,N,i):
                primes.discard(j)

    return primes</code></pre>
<p>素数のリストが欲しかったら、適当に突っ込むこと。 実際には<span class="math">\(O(n \log \log n)\)</span>だけれど、大体<span class="math">\(O(n)\)</span>だと思っていい。</p>
<h3 id="素因数分解"><a href="#素因数分解"><span class="header-section-number">7.3.2</span> 素因数分解</a></h3>
<h2 id="コンビネーション"><a href="#コンビネーション"><span class="header-section-number">7.4</span> コンビネーション</a></h2>
<p>くみあわせ。</p>
<h3 id="コンビネーションの数"><a href="#コンビネーションの数"><span class="header-section-number">7.4.1</span> コンビネーションの数</a></h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;

<span class="co">//いい感じのやつ (n=61まで大丈夫)</span>
ll combi(<span class="dt">int</span> n,<span class="dt">int</span> r){
    <span class="kw">if</span>(n &lt; r) <span class="kw">return</span> <span class="dv">0</span>;
    r = min(r,n-r);
    ll ret = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;r;i++){
        ret *= n-i;
        ret /= i<span class="dv">+1</span>;
    }
    <span class="kw">return</span> ret;
}

<span class="co">//パスカルの三角形 (n=66まで大丈夫)</span>
<span class="co">//たくさん必要になるときはこっちのほうがいい。</span>
ll combi_tri(<span class="dt">int</span> n,<span class="dt">int</span> r){
    <span class="dt">int</span> N = n<span class="dv">+1</span>;
    vector&lt;vector&lt;ll&gt; &gt; memo(N,vector&lt;ll&gt;(N,<span class="dv">0</span>));
    memo[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;N;i++){
        memo[i][<span class="dv">0</span>] = memo[i<span class="dv">-1</span>][<span class="dv">0</span>];
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;N;j++){
            memo[i][j] = memo[i<span class="dv">-1</span>][j<span class="dv">-1</span>] + memo[i<span class="dv">-1</span>][j];
        }
    }
    <span class="kw">return</span> memo[n][r];
}

<span class="co">// 重複を許してn個からk個を選ぶ。</span>
<span class="co">// 未検証</span>
ll multicombi(ll n,ll k){
    <span class="kw">return</span> combi(n+k<span class="dv">-1</span>,n<span class="dv">-1</span>);
}</code></pre>
<h3 id="列挙"><a href="#列挙"><span class="header-section-number">7.4.2</span> 列挙</a></h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){
    <span class="dt">int</span> N,M;
    cin &gt;&gt; N &gt;&gt; M;

    vector&lt;<span class="dt">int</span>&gt; numbers(N);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++) numbers[i] = i;

    stack&lt;pair&lt;<span class="dt">int</span>,vector&lt;<span class="dt">int</span>&gt; &gt; &gt; stack;
    stack.push(make_pair(<span class="dv">0</span>,vector&lt;<span class="dt">int</span>&gt;()));

    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; combis;
    <span class="kw">while</span>(!stack.empty()){
        <span class="dt">int</span> lower = stack.top().first;
        vector&lt;<span class="dt">int</span>&gt; choose = stack.top().second;
        stack.pop();

        <span class="kw">if</span>(choose.size() == M){
            combis.push_back(choose);
            <span class="kw">continue</span>;
        }

        <span class="kw">for</span>(<span class="dt">int</span> i=lower;i&lt;N-M+choose.size()+<span class="dv">1</span>;i++){
            vector&lt;<span class="dt">int</span>&gt; cop = choose;
            cop.push_back(numbers[i]);
            stack.push(make_pair(i<span class="dv">+1</span>,cop));
        }
    }

    cout &lt;&lt; <span class="st">&quot;size :&quot;</span> &lt;&lt; combis.size() &lt;&lt; endl;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;combis.size();i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;combis[i].size();j++){
            cout &lt;&lt; combis[i][j] &lt;&lt; <span class="st">&quot; &quot;</span>;
        }
        cout &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="確率的なアレ"><a href="#確率的なアレ"><span class="header-section-number">7.5</span> 確率的なアレ</a></h2>
<p>テスト中。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n&lt; 341550071728321 , ok.</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;

<span class="co">// will not overflow even if mod mod is too big..</span>
ll mod_mul(ll a,ll b,ll mod){
    <span class="kw">if</span>(b == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    ll res = mod_mul((a+a)%mod,b/<span class="dv">2</span>,mod);
    <span class="kw">if</span>(b % <span class="dv">2</span> == <span class="dv">1</span>) res = (res + a)%mod;
    <span class="kw">return</span> res;
}

<span class="co">// use mod_mul if mod is too big.</span>
ll mod_pow(ll x,ll n,ll mod){
    <span class="kw">if</span>(n==<span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    ll ret = mod_pow(x * x % mod,n/<span class="dv">2</span>,mod);
    <span class="kw">if</span>(n%<span class="dv">2</span>== <span class="dv">1</span>)  ret = ret * x % mod;
    <span class="kw">return</span> ret;
}

<span class="co">// return probably prime.</span>
<span class="co">//  if n &lt; 341550071728321 return correct answer.</span>
<span class="dt">bool</span> miller_rabin(ll n){
    <span class="kw">if</span>(n == <span class="dv">2</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span>(n % <span class="dv">2</span> == <span class="dv">0</span> <span class="kw">or</span> n &lt;= <span class="dv">1</span>) <span class="kw">return</span> <span class="kw">false</span>;
    ll s=<span class="dv">0</span>,d=n<span class="dv">-1</span>;
    <span class="dt">static</span> <span class="dt">const</span> ll a[] = {<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">17</span>,n<span class="dv">+1</span>};

    <span class="kw">while</span>(d % <span class="dv">2</span> == <span class="dv">0</span>){
        s++;d/=<span class="dv">2</span>;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;a[i]&lt;n;i++){
        ll x = mod_pow(a[i],d,n);
        <span class="kw">if</span>(x != <span class="dv">1</span>){
            ll r;
            <span class="kw">for</span>(r=<span class="dv">0</span>;r&lt;s;r++){
                <span class="kw">if</span>(x == n<span class="dv">-1</span>) <span class="kw">break</span>;
                x = mod_mul(x,x,n);
            }
            <span class="kw">if</span>(r == s) <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

ll gcd(ll a,ll b){
    <span class="kw">return</span> b==<span class="dv">0</span> ? a : gcd(b,a%b);
}

<span class="kw">inline</span> ll random(ll x,ll c,ll m){
    <span class="kw">return</span> (mod_mul(x,x,m)+c)%m;
}

vector&lt;<span class="dt">bool</span>&gt; sieve(<span class="dt">const</span> <span class="dt">int</span> M){
    vector&lt;<span class="dt">bool</span>&gt; isPrime(M);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;M;i++) isPrime[i] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i*i &lt; M;i++){
        <span class="kw">if</span>(<span class="kw">not</span> isPrime[i]) <span class="kw">continue</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=i*i;j&lt;M;j+=i){
            isPrime[j] = <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> isPrime;
}

<span class="co">// primes must contatin 2.</span>
vector&lt;ll&gt; pollard_rho(ll n,<span class="dt">const</span> vector&lt;ll&gt;&amp; primes,<span class="dt">bool</span> precheck=<span class="kw">true</span>){
    <span class="kw">if</span>(n == <span class="dv">0</span> <span class="kw">or</span> n == <span class="dv">1</span>) <span class="kw">return</span> vector&lt;ll&gt;(<span class="dv">1</span>,n);
    vector&lt;ll&gt; ret;
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> constants[] = {<span class="dv">1</span>,<span class="dv">51</span>,<span class="dv">73</span>,<span class="dv">0</span>};
    <span class="kw">if</span>(precheck){
        <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;primes.size();i++){
            <span class="kw">while</span>(n % primes[i] == <span class="dv">0</span>){
                n /= primes[i];
                ret.push_back(primes[i]);
            }
            <span class="kw">if</span>(n == <span class="dv">1</span>) <span class="kw">return</span> ret;
        }
    }
    <span class="kw">if</span>(miller_rabin(n)){
        ret.push_back(n);
        <span class="kw">return</span> ret;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;constants[i];i++){
        ll x = <span class="dv">2</span>,y = <span class="dv">2</span>,d = <span class="dv">1</span>;
        <span class="kw">while</span>(d == <span class="dv">1</span>){
            x = random(x,constants[i],n);
            y = random(random(y,constants[i],n),constants[i],n);
            d = gcd(abs(x-y),n);
        }
        <span class="kw">if</span>(d == n) <span class="kw">continue</span>;

        vector&lt;ll&gt; dp = pollard_rho(d,primes,<span class="kw">false</span>);
        vector&lt;ll&gt; ndp = pollard_rho(n/d,primes,<span class="kw">false</span>);
        <span class="kw">for</span>(size_t j=<span class="dv">0</span>;j&lt;dp.size();j++){
            ret.push_back(dp[j]);
        }
        <span class="kw">for</span>(size_t j=<span class="dv">0</span>;j&lt;ndp.size();j++){
            ret.push_back(ndp[j]);
        }
        <span class="kw">return</span> ret;
    }
    <span class="kw">return</span> ret;
}


<span class="dt">int</span> main(){
    <span class="dt">int</span> N = <span class="dv">100</span>;
    vector&lt;<span class="dt">bool</span>&gt; isprime = sieve(<span class="dv">5</span>);
    vector&lt;ll&gt; primes;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;isprime.size();i++){
        <span class="kw">if</span>(isprime[i]){
            primes.push_back(i);
        }
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
        <span class="co">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; miller_rabin(i) &lt;&lt; &quot; &quot; &lt;&lt; endl;</span>
        vector&lt;ll&gt; ps = pollard_rho(i,primes,<span class="kw">true</span>);
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;ps.size();j++){
            cout &lt;&lt; ps[j] &lt;&lt; <span class="st">&quot; &quot;</span>;
        }
        cout &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="ヨセフス数"><a href="#ヨセフス数"><span class="header-section-number">7.6</span> ヨセフス数</a></h2>
<h2 id="乱数"><a href="#乱数"><span class="header-section-number">7.7</span> 乱数</a></h2>
<p>XORShiftをつかったらうれしいかもしれない。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">long</span> xor128(){
    <span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">long</span> x=<span class="dv">123456789</span>,y=<span class="dv">362436069</span>,z=<span class="dv">521288629</span>,w=<span class="dv">88675123</span>;
    <span class="dt">unsigned</span> <span class="dt">long</span> t;
    t=(x^(x&lt;&lt;<span class="dv">11</span>));x=y;y=z;z=w; <span class="kw">return</span>( w=(w^(w&gt;&gt;<span class="dv">19</span>))^(t^(t&gt;&gt;<span class="dv">8</span>)) );
}</code></pre>
<h2 id="基数変換"><a href="#基数変換"><span class="header-section-number">7.8</span> 基数変換</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; int_to_digits(<span class="dt">int</span> base,<span class="dt">int</span> N){
    vector&lt;<span class="dt">int</span>&gt; rev_ret;
    <span class="kw">while</span>(N != <span class="dv">0</span>){
        rev_ret.push_back(N % base);
        N /= base;
    }
    reverse(all(rev_ret));
    <span class="kw">return</span> rev_ret;
}

<span class="dt">int</span> digits_to_int(<span class="dt">int</span> base,<span class="dt">const</span> vector&lt;<span class="dt">int</span>&gt;&amp; digits){
    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;(<span class="dt">int</span>)digits.size();i++){
        ret *= base;
        ret += digits[i];
    }
    <span class="kw">return</span> ret;
}</code></pre>
<h1 id="行列"><a href="#行列"><span class="header-section-number">8</span> 行列</a></h1>
<h2 id="基本要素"><a href="#基本要素"><span class="header-section-number">8.1</span> 基本要素</a></h2>
<p>正方行列用 //いつかなおす。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 適宜intにしたりすること。</span>
<span class="kw">typedef</span> vector&lt;vector&lt;ll&gt; &gt; ll_mat;</code></pre>
<h2 id="基本演算"><a href="#基本演算"><span class="header-section-number">8.2</span> 基本演算</a></h2>
<p>かけ算とmod。たしざんはcoming soon.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std{
    ll_mat <span class="kw">operator</span>*(<span class="dt">const</span> ll_mat&amp; lhs,<span class="dt">const</span> ll_mat&amp; rhs){
        <span class="dt">int</span> N = lhs.size();
        ll_mat ret(N,vector&lt;ll&gt;(N));
        <span class="kw">for</span>(<span class="dt">int</span> row=<span class="dv">0</span>;row&lt;N;row++){
            <span class="kw">for</span>(<span class="dt">int</span> col=<span class="dv">0</span>;col&lt;N;col++){
                <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;N;k++){
                    ret[row][col] += rhs[row][k] * lhs[k][col];
                }
            }
        }
        <span class="kw">return</span> ret;
    }

    ll_mat <span class="kw">operator</span>%(ll_mat lhs,ll rhs){
        <span class="dt">int</span> N = lhs.size();
        ll_mat ret = lhs;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;N;j++){
                ret[i][j] = ret[i][j] % rhs;
            }
        }
        <span class="kw">return</span> ret;
    }
};</code></pre>
<h2 id="基本操作"><a href="#基本操作"><span class="header-section-number">8.3</span> 基本操作</a></h2>
<h3 id="累乗"><a href="#累乗"><span class="header-section-number">8.3.1</span> 累乗</a></h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;vector&lt;ll&gt; &gt;  mod_pow(vector&lt;vector&lt;ll&gt; &gt; x,ll n,ll mod){
    <span class="kw">if</span>(n==<span class="dv">0</span>){
        vector&lt;vector&lt;ll&gt; &gt; E(x.size(),vector&lt;ll&gt;(x.size()));
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;x.size();i++){
            E[i][i] = <span class="dv">1</span>;
        }
        <span class="kw">return</span> E;
    }
    vector&lt;vector&lt;ll&gt; &gt; ret = mod_pow(x * x % mod,n/<span class="dv">2</span>,mod);
    <span class="kw">if</span>(n%<span class="dv">2</span> == <span class="dv">1</span>)  ret = ret * x % mod;
    <span class="kw">return</span> ret;
}</code></pre>
<h3 id="表示"><a href="#表示"><span class="header-section-number">8.3.2</span> 表示</a></h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> display_matrix(vector&lt;vector&lt;ll&gt; &gt; mat){
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;mat.size();i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;mat[<span class="dv">0</span>].size();j++){
            cerr &lt;&lt; mat[i][j] &lt;&lt; <span class="st">&quot; &quot;</span>;
        }
        cerr &lt;&lt; endl;
    }
}</code></pre>
<h3 id="ベクトルとのかけ算"><a href="#ベクトルとのかけ算"><span class="header-section-number">8.3.3</span> ベクトルとのかけ算</a></h3>
<p>一次元列ベクトルとのかけ算</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;ll&gt; mat_multi(vector&lt;vector&lt;ll&gt; &gt; lhs,vector&lt;ll&gt; rhs,<span class="dt">int</span> mod){
    vector&lt;ll&gt; ret(rhs.size());
    <span class="dt">int</span> N = lhs.size();
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;N;j++){
            ret[i] = (ret[i] + lhs[i][j] * rhs[j]) % mod;;
        }
    }
    <span class="kw">return</span> ret;
}</code></pre>
<h2 id="テスト"><a href="#テスト"><span class="header-section-number">8.4</span> テスト</a></h2>
<p>AOJ 1327</p>
<h2 id="gauss-jordan"><a href="#gauss-jordan"><span class="header-section-number">8.5</span> Gauss-Jordan</a></h2>
<p>GF上で連立方程式を解く</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Gauss-Jordan. Solve equation on GF.</span>
<span class="dt">int</span> invert(<span class="dt">int</span> x){
    <span class="dt">int</span> ret[<span class="dv">2</span>] = {<span class="dv">0</span>,<span class="dv">1</span>};
    <span class="kw">return</span> ret[x];
}

<span class="dt">int</span> modulo(<span class="dt">int</span> x){
    x %= <span class="dv">2</span>;
    <span class="kw">while</span>(x &lt; <span class="dv">0</span>){
        x += <span class="dv">2</span>;
    }
    <span class="kw">return</span> x;
}

<span class="dt">const</span> <span class="dt">int</span> none = <span class="dv">0</span>; <span class="co">// if no answer</span>
<span class="dt">const</span> <span class="dt">int</span> one = <span class="dv">1</span>;  <span class="co">// if there is exactly one answer</span>
<span class="dt">const</span> <span class="dt">int</span> many = <span class="dv">2</span>; <span class="co">// many answer.</span>
<span class="co">// answer will be inserted in b.</span>
<span class="dt">int</span> gauss(matrix A,vector&lt;<span class="dt">int</span>&gt;&amp; b){
    <span class="dt">int</span> n = A.size();
    <span class="dt">int</span> m = A[<span class="dv">0</span>].size();
    <span class="dt">int</span> pi = <span class="dv">0</span>,pj = <span class="dv">0</span>;
    <span class="kw">while</span>(pi &lt; n <span class="kw">and</span> pj &lt; m){
        <span class="kw">for</span>(<span class="dt">int</span> i=pi<span class="dv">+1</span>;i&lt;n;i++){ <span class="co">// pivot</span>
            <span class="kw">if</span>(abs(A[i][pj]) &gt; abs(A[pi][pj])){
                swap(A[i],A[pi]);
                swap(b[i],b[pi]);
            }
        }
        <span class="kw">if</span>(abs(A[pi][pj]) &gt; <span class="dv">0</span>){
            <span class="dt">int</span> d = invert(A[pi][pj]);
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
                A[pi][j] = modulo(A[pi][j] * d);
            }
            b[pi] = modulo(b[pi]*d);
            <span class="kw">for</span>(<span class="dt">int</span> i=pi<span class="dv">+1</span>;i&lt;n;i++){
                <span class="dt">int</span> k = A[i][pj];
                <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
                    A[i][j] = modulo(A[i][j] - k * A[pi][j]);
                }
                b[i] = modulo(b[i] - k*b[pi]);
            }
            pi++;
        }
        pj++;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=pi;i&lt;n;i++){
        <span class="kw">if</span>(abs(b[i]) &gt; <span class="dv">0</span>){
            <span class="kw">return</span> none;
        }
    }
    <span class="kw">if</span>(pi &lt; m <span class="kw">or</span> pj &lt; m){
        <span class="kw">return</span> many;
    }
    <span class="kw">for</span>(<span class="dt">int</span> j=m<span class="dv">-1</span>;j&gt;=<span class="dv">0</span>;j--){
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;j;i++){
            b[i] = modulo(b[i] - b[j] * A[i][j]);
        }
    }
    <span class="kw">return</span> one;
}</code></pre>
<h1 id="動的計画法およびそれに似たやつらtodo"><a href="#動的計画法およびそれに似たやつらtodo"><span class="header-section-number">9</span> 動的計画法およびそれに似たやつら。(TODO)</a></h1>
<h2 id="lcs"><a href="#lcs"><span class="header-section-number">9.1</span> LCS</a></h2>
<p>Longest common sequence.</p>
<h2 id="lis"><a href="#lis"><span class="header-section-number">9.2</span> LIS</a></h2>
<p>Longest increasing subsequence.</p>
<h2 id="巡回セールスマン問題"><a href="#巡回セールスマン問題"><span class="header-section-number">9.3</span> 巡回セールスマン問題</a></h2>
<p>bit演算をする。bitのループを先に回すこと。<span class="math">\(O(N^2\times2^{N})\)</span></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ll dp[<span class="dv">1</span> &lt;&lt; N][N];
dp[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
<span class="co">// Bitのほうが先!</span>
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;(<span class="dv">1</span>&lt;&lt;N);i++){
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;N;j++){
        <span class="co">//something.</span>
    }
}</code></pre>
<h2 id="ナップサック問題"><a href="#ナップサック問題"><span class="header-section-number">9.4</span> ナップサック問題</a></h2>
<p>個数制限なしのとき</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define rep(i,n) for(int i=0;i&lt;(int)n;i++)</span>

<span class="kw">typedef</span> vector&lt;<span class="dt">int</span>&gt; vi;

<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="kw">inline</span> <span class="dt">int</span> len(<span class="dt">const</span> T&amp; t){
    <span class="kw">return</span> t.size();
}

<span class="kw">struct</span> Treasure{
    <span class="dt">int</span> value,weight;
    Treasure():
        value(<span class="dv">0</span>),weight(<span class="dv">0</span>) {};
    Treasure(<span class="dt">int</span> _value,<span class="dt">int</span> _weight)
        : value(_value),weight(_weight) {}
};

<span class="dt">int</span> main(){
    <span class="dt">int</span> W,N;
    cin &gt;&gt; W;
    cin &gt;&gt; N;
    vector&lt;Treasure&gt; v(N);
    rep(i,N){
        cin &gt;&gt; v[i].value &gt;&gt; v[i].weight;
    }
    <span class="co">// もしも複数入れて良いなら、直接valueを更新する。</span>
    vi value(W<span class="dv">+1</span>);
    rep(n,N){
        vi tmp(W<span class="dv">+1</span>);
        rep(i,W<span class="dv">+1</span>){
            tmp[i] = max(tmp[i],value[i]);
            <span class="dt">int</span> in = i+v[n].weight;
            <span class="kw">if</span>(in &lt;= W){
                tmp[in] = max(tmp[in],value[i]+v[n].value);
            }
        }
        value.swap(tmp);
    }

    <span class="dt">int</span> retw=<span class="dv">0</span>;
    <span class="dt">int</span> retv=<span class="dv">0</span>;
    rep(i,len(value)){
        <span class="kw">if</span>(value[i] &gt; retv){
            retv = value[i];
            retw = i;
        }
    }
    cout &lt;&lt; retv &lt;&lt; endl &lt;&lt; retw &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h1 id="データ構造"><a href="#データ構造"><span class="header-section-number">10</span> データ構造</a></h1>
<h2 id="union-find"><a href="#union-find"><span class="header-section-number">10.1</span> Union-Find</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> UnionFind{
    vector&lt;<span class="dt">int</span>&gt; par; <span class="co">// 親</span>
    vector&lt;<span class="dt">int</span>&gt; rank; <span class="co">// 木の深さ</span>
    UnionFind(<span class="dt">int</span> n){
        rep(i,n) par.push_back(i);
        rank = vector&lt;<span class="dt">int</span>&gt;(n);
    }
    <span class="co">// 親を探す</span>
    <span class="dt">int</span> root(<span class="dt">int</span> x){
        <span class="kw">if</span>(par[x] == x){
            <span class="kw">return</span> x;
        }<span class="kw">else</span>{
            <span class="co">// 縮約</span>
            <span class="kw">return</span> par[x] = root(par[x]);
        }
    }
    <span class="co">// x,yの含まれる集合を併合</span>
    <span class="dt">void</span> unite(<span class="dt">int</span> x,<span class="dt">int</span> y){
        x = root(x);
        y = root(y);
        <span class="kw">if</span>(x==y) <span class="kw">return</span>;
        <span class="kw">if</span>(rank[x] &lt; rank[y]){
            par[x] = y;
        }<span class="kw">else</span>{
            par[y] = x;
            <span class="kw">if</span>(rank[x] == rank[y]) rank[x]++;
        }
    }
    <span class="co">// 同じ集合にいるかどうか</span>
    <span class="dt">bool</span> same(<span class="dt">int</span> x,<span class="dt">int</span> y){
        <span class="kw">return</span> root(x) == root(y);
    }
};</code></pre>
<h2 id="ヒープ"><a href="#ヒープ"><span class="header-section-number">10.2</span> ヒープ</a></h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;

<span class="kw">struct</span> Comp{
    <span class="dt">bool</span> <span class="kw">operator</span>()(pii left,pii right){
        <span class="kw">if</span>(left.second &lt; right.second) <span class="kw">return</span> <span class="kw">true</span>;
        <span class="kw">else</span> <span class="kw">if</span>(left.second == right.second <span class="kw">and</span> left.first &gt; right.first) <span class="kw">return</span> <span class="kw">true</span>;
        <span class="kw">else</span> <span class="kw">return</span> <span class="kw">false</span>;
    };
};

<span class="kw">struct</span> Robot{
    <span class="dt">int</span> y,x,dir,step;
    Robot(<span class="dt">int</span> y,<span class="dt">int</span> x,<span class="dt">int</span> dir,<span class="dt">int</span> step) : y(y),x(x),dir(dir),step(step) {};
};

<span class="co">// &lt;,&gt;を定義すればless&lt;Robot&gt;みたいに扱える。</span>
<span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Robot&amp; lhs,<span class="dt">const</span> Robot&amp; rhs){
    <span class="kw">return</span> lhs.step &lt; rhs.step;
}
<span class="dt">bool</span> <span class="kw">operator</span>&gt;(<span class="dt">const</span> Robot&amp; lhs,<span class="dt">const</span> Robot&amp; rhs){
    <span class="kw">return</span> lhs.step &gt; rhs.step;
}

<span class="dt">int</span> main(){
    <span class="co">// 何も書かないと降順。(おっきい方からでてくる。)</span>
    <span class="co">// これは昇順(ちいさいほうから出てくる)にしたもの。</span>
    priority_queue&lt;<span class="dt">int</span>,vector&lt;<span class="dt">int</span>&gt;,greater&lt;<span class="dt">int</span>&gt; &gt; Qi;
    <span class="co">//関数オブジェクトを使っていい感じにもできる。</span>
    priority_queue&lt;pii,vector&lt;pii&gt;,Comp&gt; Q;
    <span class="co">// 自作クラスの場合はこんな感じ</span>
    priority_queue&lt;Robot,vector&lt;Robot&gt;,greater&lt;Robot&gt; &gt; que;

    Q.push(make_pair(<span class="dv">1</span>,<span class="dv">2</span>));
    Q.push(make_pair(<span class="dv">2</span>,<span class="dv">2</span>));
    Q.push(make_pair(<span class="dv">3</span>,<span class="dv">2</span>));
    <span class="kw">while</span>(<span class="kw">not</span> Q.empty()){
        cout &lt;&lt; Q.top().first &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; Q.top().second &lt;&lt; endl;
        Q.pop();
    }
}</code></pre>
<h2 id="bitset"><a href="#bitset"><span class="header-section-number">10.3</span> bitset</a></h2>
<p>限られた大きさのvector&lt;bool&gt;を使いたいときに、bitsetを使うことができる。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;bitset&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">10</span>;

<span class="kw">struct</span> bit_cmp{
    <span class="dt">bool</span> <span class="kw">operator</span>() (<span class="dt">const</span> bitset&lt;N&gt; &amp;left,<span class="dt">const</span> bitset&lt;N&gt; &amp;right) {
        <span class="kw">for</span>(<span class="dt">int</span> i=N<span class="dv">-1</span>;i&gt;=<span class="dv">0</span>;i--){
            <span class="kw">if</span>(left[i] &lt; right[i]) <span class="kw">return</span> <span class="kw">true</span>;
            <span class="kw">if</span>(left[i] &gt; right[i]) <span class="kw">return</span> <span class="kw">false</span>;
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }
};


<span class="dt">int</span> main(){
    <span class="co">//定数じゃないとダメ。最初は全部false</span>
    bitset&lt;N&gt; bits;
    <span class="co">// すべての要素をtrue -&gt; 1111111111</span>
    bits.set();
    <span class="kw">if</span>(bits.all()) cout &lt;&lt; <span class="st">&quot;all&quot;</span> &lt;&lt; endl;
    <span class="co">// 立っているbitの数 -&gt; 10</span>
    cout &lt;&lt; bits.count() &lt;&lt; endl;
    <span class="co">// すべての要素をfalse -&gt; 0000000000</span>
    bits.reset();
    <span class="kw">if</span>(bits.none()) cout &lt;&lt; <span class="st">&quot;none&quot;</span> &lt;&lt; endl;

    <span class="co">//1番目の要素をtrue -&gt; 0100000000</span>
    bits.set(<span class="dv">1</span>);
    <span class="kw">if</span>(bits.any()) cout &lt;&lt; <span class="st">&quot;any&quot;</span> &lt;&lt; endl;

    <span class="co">// 0110000000</span>
    bits.set(<span class="dv">2</span>);
    <span class="co">//1番目の要素をfalse -&gt; 0010000000</span>
    bits.reset(<span class="dv">1</span>);

    <span class="kw">if</span>(bits[<span class="dv">2</span>]) cout &lt;&lt; <span class="dv">2</span> &lt;&lt; endl;
    cout &lt;&lt; bits &lt;&lt; endl;

    bitset&lt;N&gt; newbits;
    <span class="co">// 和を取る</span>
    bits |= newbits;
    <span class="co">// 積を取る</span>
    bits &amp;= newbits;

    <span class="co">// 関数オブジェクトを作る必要アリ</span>
    map&lt;bitset&lt;N&gt;,<span class="dt">int</span>,bit_cmp&gt; M;
}</code></pre>
<h2 id="分数"><a href="#分数"><span class="header-section-number">10.4</span> 分数</a></h2>
<p>テストちゅう.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;
ll gcd(ll a,ll b){
    <span class="kw">return</span> b==<span class="dv">0</span> ? a : gcd(b,a%b);
}

ll lcm(ll a,ll b){
    <span class="kw">if</span>(a &lt; <span class="dv">0</span>) a *= -<span class="dv">1</span>;
    <span class="kw">if</span>(b &lt; <span class="dv">0</span>) b *= -<span class="dv">1</span>;
    <span class="kw">return</span> a*b / gcd(a,b);
}

<span class="kw">struct</span> Fraction{
    ll n,d;
    Fraction(ll _n,ll _d){
        ll c = lcm(_n,_d);
        n = c / _d;
        d = c / _n;
        <span class="kw">if</span>(d &lt; <span class="dv">0</span>){
            n *= -<span class="dv">1</span>;
            d *= -<span class="dv">1</span>;
        }
    }

    Fraction(ll _n){
        Fraction(_n,<span class="dv">1</span>);
    }

    <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        ll c_d = lcm(d,r.d);
        <span class="kw">return</span> n*(c_d/d)&lt; r.n*(c_d/r.d);
    }
    <span class="dt">bool</span> <span class="kw">operator</span>&gt;(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> <span class="kw">not</span> ((*<span class="kw">this</span>) &lt; r <span class="kw">or</span> (*<span class="kw">this</span>) == r);
    }
    <span class="dt">bool</span> <span class="kw">operator</span>&lt;=(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) &lt; r <span class="kw">or</span> (*<span class="kw">this</span>) == r;
    }
    <span class="dt">bool</span> <span class="kw">operator</span>&gt;=(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) &gt; r <span class="kw">or</span> (*<span class="kw">this</span>) == r;
    }
    <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> n == r.n <span class="kw">and</span> d == r.d;
    }
    Fraction <span class="kw">operator</span>+(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        ll c_d = lcm(d,r.d);
        <span class="kw">return</span> Fraction(n*(c_d/d)+r.n*(c_d/r.d),c_d);
    }
    Fraction <span class="kw">operator</span>-(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) + (-r);
    }
    Fraction <span class="kw">operator</span>*(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> Fraction(n*r.n,d*r.d);
    }
    Fraction <span class="kw">operator</span>/(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) * Fraction(r.d,r.n);
    }
    Fraction <span class="kw">operator</span>+() <span class="dt">const</span>{
        <span class="kw">return</span> Fraction(n,d);
    }
    Fraction <span class="kw">operator</span>-() <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) * -<span class="dv">1</span>;
    }
    Fraction <span class="kw">operator</span>*(<span class="dt">const</span> ll&amp; a) <span class="dt">const</span>{
        <span class="kw">return</span> Fraction(a*n,d) ;
    }
};

ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream &amp;os,<span class="dt">const</span> Fraction&amp; f){
    os &lt;&lt; f.n &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; f.d;
    <span class="kw">return</span> os;
}</code></pre>
<h1 id="グラフ"><a href="#グラフ"><span class="header-section-number">11</span> グラフ</a></h1>
<h2 id="構成要素"><a href="#構成要素"><span class="header-section-number">11.1</span> 構成要素</a></h2>
<p>隣接行列を使うか、vector&lt;Edge&gt;みたいのを使うかの二択。場合によってはNode みたいなのも使うかも。隣接行列を使うとメモリとか探すのとか重い。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cost;
    Edge(<span class="dt">int</span> to,<span class="dt">int</span> cost) : to(to),cost(cost) {};
};</code></pre>
<h2 id="ベルマンフォード"><a href="#ベルマンフォード"><span class="header-section-number">11.2</span> ベルマンフォード</a></h2>
<p>O(N|E|)</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1</span> &lt;&lt; <span class="dv">30</span>;
<span class="co">// s:始点,dist:距離,prev:最短経路木</span>
<span class="dt">bool</span> bellman(<span class="dt">const</span> vector&lt;vector&lt;Edge&gt; &gt;&amp; graph,<span class="dt">int</span> s,vector&lt;<span class="dt">int</span>&gt; &amp;dist,vector&lt;<span class="dt">int</span>&gt; &amp;prev){
    <span class="dt">int</span> n = graph.size();
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++) dist[i] = INF;
    dist[s] = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++) prev[i] = -<span class="dv">1</span>;

    <span class="dt">bool</span> neg_cycle = <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;n;j++){
            <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;graph[j].size();k++){
                <span class="dt">const</span> Edge &amp;e = graph[j][k];
                <span class="kw">if</span>(dist[e.to] &gt; dist[e.from] + e.cost){
                    dist[e.to] = dist[e.from] + e.cost;
                    prev[e.to] = e.from;
                    <span class="kw">if</span>(i == n<span class="dv">-1</span>){
                        dist[e.to] = -INF;
                        neg_cycle = <span class="kw">true</span>;
                    }
                }
            }
        }
    }
    <span class="kw">return</span> !neg_cycle;
}</code></pre>
<h2 id="ダイクストラ"><a href="#ダイクストラ"><span class="header-section-number">11.3</span> ダイクストラ</a></h2>
<p>負の経路があったらダメ</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;utility&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;functional&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> from,to,cost;
    Edge(<span class="dt">int</span> from,<span class="dt">int</span> to,<span class="dt">int</span> cost)
        : from(from),to(to),cost(cost) {};
};

<span class="dt">int</span> main(){
    <span class="dt">int</span> n,m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;Edge&gt; &gt; V(m);

    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        <span class="dt">int</span> a,b,cost;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; cost;
        V[a].push_back(Edge(a,b,cost));
        V[b].push_back(Edge(b,a,cost));
    }

    <span class="dt">int</span> ret = -<span class="dv">1</span>;
    <span class="dt">int</span> p,q;
    cin &gt;&gt; p &gt;&gt; q;
    vector&lt;<span class="dt">char</span>&gt; visited(m,<span class="kw">false</span>);
    <span class="co">//                 cost,where</span>
    priority_queue&lt;pii,vector&lt;pii&gt;, greater&lt;pii&gt; &gt; Q;
    Q.push(make_pair(<span class="dv">0</span>,p));
    <span class="kw">while</span>(!Q.empty()){
        <span class="dt">int</span> cost,where;
        cost = Q.top().first;
        where = Q.top().second;
        Q.pop();
        <span class="kw">if</span>(visited[where]) <span class="kw">continue</span>;
        <span class="kw">if</span>(where == q){
             ret = cost;
             <span class="kw">break</span>;
        }
        visited[where] = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;(<span class="dt">int</span>)V[where].size();j++){
            Q.push(make_pair(V[where][j].cost+cost,V[where][j].to));
        }
    }
    <span class="co">// 到達不能なときは-1</span>
    cout &lt;&lt; ret &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="ワーシャルフロイド"><a href="#ワーシャルフロイド"><span class="header-section-number">11.4</span> ワーシャルフロイド</a></h2>
<p>負の経路があってもOK。すべてのノードに対してすべてのノードへの距離を求め る。もし負の閉路があったらiからiはマイナスになる。<span class="math">\(O(|V|^{3})\)</span></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// m はノードの個数。NOはでかい数</span>
vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; V(m,vector&lt;<span class="dt">int</span>&gt;(m,NO));
<span class="co">// i-&gt;iは0にする。</span>
rep(i,m){
    V[i][i] = <span class="dv">0</span>;
}

<span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;m;k++){
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
            V[i][j] = min(V[i][j],V[i][k]+V[k][j]);
        }
    }
}</code></pre>
<h2 id="最小全域木"><a href="#最小全域木"><span class="header-section-number">11.5</span> 最小全域木</a></h2>
<p>プラム法による。<span class="math">\(O(N^3\)</span>)だと思う。最小コストを求めるコードが以下。 ただし、vector<Edge>を使えばもっとよい。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;

<span class="dt">int</span> main(){
    <span class="dt">int</span> N;
    <span class="kw">while</span>(cin &gt;&gt; N){
        vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; M(N,vector&lt;<span class="dt">int</span>&gt;(N));
        <span class="co">// 距離行列を読みこむ</span>
        rep(i,N) rep(j,N) cin &gt;&gt; M[i][j];
        vector&lt;<span class="dt">char</span>&gt; used(N,<span class="kw">false</span>);
        ll ret = <span class="dv">0</span>;
        <span class="co">// cost , where.</span>
        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; Q;
        Q.push(mp(<span class="dv">0</span>,<span class="dv">0</span>));
        <span class="kw">while</span>(!Q.empty()){
            <span class="dt">int</span> cost = Q.top().first;
            <span class="dt">int</span> where = Q.top().second;
            Q.pop();
            <span class="kw">if</span>(used[where]) <span class="kw">continue</span>;
            used[where] = <span class="kw">true</span>;
            ret += cost;
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
                Q.push(mp(M[where][i],i));
            }
        }
        cout &lt;&lt; ret &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="最大流"><a href="#最大流"><span class="header-section-number">11.6</span> 最大流</a></h2>
<p>Dinic法による。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cap,rev;
    Edge(<span class="dt">int</span> to,<span class="dt">int</span> cap,<span class="dt">int</span> rev) : to(to),cap(cap),rev(rev) {};
};

<span class="dt">void</span> add_edge(vector&lt;vector&lt;Edge&gt; &gt;&amp; E,<span class="dt">int</span> from,<span class="dt">int</span> to,<span class="dt">int</span> cap){
    E[from].push_back(Edge(to,cap,E[to].size()));
    E[to].push_back(Edge(from,<span class="dv">0</span>,E[from].size()-<span class="dv">1</span>));
}

vector&lt;<span class="dt">int</span>&gt; levels(vector&lt;vector&lt;Edge&gt; &gt; &amp;E,<span class="dt">int</span> s){
    vector&lt;<span class="dt">int</span>&gt; level(E.size(),-<span class="dv">1</span>);
    level[s] = <span class="dv">0</span>;
    queue&lt;<span class="dt">int</span>&gt; Q;
    Q.push(s);
    <span class="kw">while</span>(!Q.empty()){
        <span class="dt">int</span> v = Q.front();
        Q.pop();
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;E[v].size();i++){
            Edge &amp;e = E[v][i];
            <span class="kw">if</span>(e.cap &gt; <span class="dv">0</span> <span class="kw">and</span> level[e.to] == -<span class="dv">1</span>){
                level[e.to] = level[v]+<span class="dv">1</span>;
                Q.push(e.to);
            }
        }
    }
    <span class="kw">return</span> level;
}

<span class="dt">int</span> good_path(vector&lt;vector&lt;Edge&gt; &gt; &amp;E,
        vector&lt;<span class="dt">int</span>&gt; &amp;iter,
        vector&lt;<span class="dt">int</span>&gt; &amp;level,
        <span class="dt">int</span> v,<span class="dt">int</span> t,<span class="dt">int</span> f){
    <span class="kw">if</span>(v == t) <span class="kw">return</span> f;
    <span class="kw">for</span>(<span class="dt">int</span> &amp;i=iter[v];i&lt;E[v].size();i++){
        Edge &amp;e = E[v][i];
        <span class="kw">if</span>(e.cap &gt; <span class="dv">0</span> <span class="kw">and</span> level[v] &lt; level[e.to]){
            <span class="dt">int</span> d = good_path(E,iter,level,e.to,t,min(f,e.cap));
            <span class="kw">if</span>(d &gt; <span class="dv">0</span>){
                e.cap -= d;
                E[e.to][e.rev].cap += d;
                <span class="kw">return</span> d;
            }
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> max_flow(vector&lt;vector&lt;Edge&gt; &gt; E,<span class="dt">int</span> s,<span class="dt">int</span> t){
    <span class="dt">int</span> flow = <span class="dv">0</span>;
    <span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1</span> &lt;&lt; <span class="dv">30</span>;
    <span class="kw">while</span>(<span class="kw">true</span>){
        vector&lt;<span class="dt">int</span>&gt; level = levels(E,s);
        <span class="kw">if</span>(level[t] &lt; <span class="dv">0</span>) <span class="kw">return</span> flow;
        vector&lt;<span class="dt">int</span>&gt; iter(E.size());
        <span class="dt">int</span> f;
        <span class="kw">while</span>((f=good_path(E,iter,level,s,t,INF)) &gt; <span class="dv">0</span>){
            flow += f;
        }
    }
}

<span class="dt">int</span> main(){
    <span class="dt">int</span> N,M;
    <span class="kw">while</span>(cin &gt;&gt; N &gt;&gt; M){
        <span class="co">// [0,N) is cow,[N,N+M) is barn.</span>
        vector&lt;vector&lt;Edge&gt; &gt; E(N+M<span class="dv">+2</span>);
        <span class="dt">int</span> s = N+M;
        <span class="dt">int</span> t = N+M<span class="dv">+1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
            add_edge(E,s,i,<span class="dv">1</span>);
        }
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;M;i++){
            add_edge(E,N+i,t,<span class="dv">1</span>);
        }

        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
            <span class="dt">int</span> S;
            cin &gt;&gt; S;
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;S;j++){
                <span class="dt">int</span> k;
                cin &gt;&gt; k;
                k--;
                add_edge(E,i,N+k,<span class="dv">1</span>);
            }
        }

        cout &lt;&lt; max_flow(E,s,t) &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="最小費用流"><a href="#最小費用流"><span class="header-section-number">11.7</span> 最小費用流</a></h2>
<p>Primal-Dual法による。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cap,cost,rev;
    Edge(<span class="dt">int</span> to,<span class="dt">int</span> cap,<span class="dt">int</span> cost,<span class="dt">int</span> rev)
        : to(to),cap(cap),cost(cost),rev(rev) {};
};

<span class="dt">void</span> add_edge(vector&lt;vector&lt;Edge&gt; &gt; &amp;E,<span class="dt">int</span> from,<span class="dt">int</span> to,<span class="dt">int</span> cap,<span class="dt">int</span> cost){
    E[from].push_back(Edge(to,cap,cost,E[to].size()));
    E[to].push_back(Edge(from,<span class="dv">0</span>,-cost,E[from].size()-<span class="dv">1</span>));
}

<span class="co">// s -&gt; t (flow f)</span>
<span class="co">//  if cant, return -1.</span>
<span class="dt">int</span> min_cost_flow(vector&lt;vector&lt;Edge&gt; &gt; E,<span class="dt">int</span> s,<span class="dt">int</span> t,<span class="dt">int</span> f){
    <span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1</span> &lt;&lt; <span class="dv">30</span>;
    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="co">// potential</span>
    vector&lt;<span class="dt">int</span>&gt; h(E.size());
    vector&lt;<span class="dt">int</span>&gt; prevv(E.size());
    vector&lt;<span class="dt">int</span>&gt; preve(E.size());

    <span class="kw">while</span>(f &gt; <span class="dv">0</span>){
        vector&lt;<span class="dt">int</span>&gt; dist(E.size(),INF);
        dist[s] = <span class="dv">0</span>;
        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; que;
        que.push(make_pair(<span class="dv">0</span>,s));
        <span class="kw">while</span>(!que.empty()){
            pii p = que.top();
            que.pop();
            <span class="dt">int</span> pf = p.first,ps = p.second;
            <span class="kw">if</span>(dist[ps] &lt; pf) <span class="kw">continue</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;E[ps].size();i++){
                Edge &amp;e = E[ps][i];
                <span class="kw">if</span>(e.cap &gt; <span class="dv">0</span> <span class="kw">and</span> dist[e.to] &gt; dist[ps] + e.cost + h[ps] - h[e.to]){
                    dist[e.to] = dist[ps] + e.cost + h[ps] - h[e.to];
                    prevv[e.to] = ps;
                    preve[e.to] = i;
                    que.push(make_pair(dist[e.to],e.to));
                }
            }
        }
        <span class="kw">if</span>(dist[t] == INF){
            <span class="kw">return</span> -<span class="dv">1</span>;
        }
        <span class="kw">for</span>(<span class="dt">int</span> v=<span class="dv">0</span>;v&lt;E.size();v++){
            h[v] += dist[v];
        }
        <span class="dt">int</span> d = f;
        <span class="kw">for</span>(<span class="dt">int</span> v=t;v!=s;v=prevv[v]){
            d = min(d,E[prevv[v]][preve[v]].cap);
        }
        f -= d;
        ret += d * h[t];
        <span class="kw">for</span>(<span class="dt">int</span> v=t;v!=s;v=prevv[v]){
            Edge &amp;e = E[prevv[v]][preve[v]];
            e.cap -= d;
            E[v][e.rev].cap += d;
        }
    }
    <span class="kw">return</span> ret;
}

<span class="dt">int</span> main(){
    <span class="kw">while</span>(<span class="kw">true</span>){
        <span class="dt">int</span> N,M;
        cin &gt;&gt; N &gt;&gt; M;
        <span class="kw">if</span>(N == <span class="dv">0</span> <span class="kw">and</span> M == <span class="dv">0</span>) <span class="kw">break</span>;
        vector&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; &gt; men;
        vector&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; &gt; houses;
        <span class="kw">for</span>(<span class="dt">int</span> h=<span class="dv">0</span>;h&lt;N;h++){
            <span class="kw">for</span>(<span class="dt">int</span> w=<span class="dv">0</span>;w&lt;M;w++){
                <span class="dt">char</span> x;
                cin &gt;&gt; x;
                <span class="kw">if</span>(x == &#39;H&#39;) houses.push_back(make_pair(h,w));
                <span class="kw">else</span> <span class="kw">if</span>(x == &#39;m&#39;) men.push_back(make_pair(h,w));
            }
        }

        vector&lt;vector&lt;Edge&gt; &gt; E(men.size()+houses.size()+<span class="dv">2</span>);
        <span class="dt">int</span> s = men.size()+houses.size();
        <span class="dt">int</span> t = s<span class="dv">+1</span>;

        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;men.size();i++){
            add_edge(E,s,i,<span class="dv">1</span>,<span class="dv">0</span>);
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;houses.size();j++){
                <span class="dt">int</span> dist = abs(men[i].first - houses[j].first)
                    + abs(men[i].second - houses[j].second);
                add_edge(E,i,men.size()+j,<span class="dv">1</span>,dist);
            }
        }

        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;houses.size();i++){
            add_edge(E,men.size()+i,t,<span class="dv">1</span>,<span class="dv">0</span>);
        }

        cout &lt;&lt; min_cost_flow(E,s,t,men.size()) &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h1 id="幾何"><a href="#幾何"><span class="header-section-number">12</span> 幾何</a></h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;complex&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">double</span> EPS = <span class="fl">1e-9</span>;
<span class="kw">typedef</span> complex&lt;<span class="dt">double</span>&gt; point;
<span class="kw">typedef</span> vector&lt;point&gt; vertex;

<span class="kw">namespace</span> std{
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> point &amp;lhs,<span class="dt">const</span> point &amp;rhs){
        <span class="kw">if</span>(real(lhs) == real(rhs)){
            <span class="kw">return</span> imag(lhs) &lt; imag(rhs);
        }<span class="kw">else</span>{
            <span class="kw">return</span> real(lhs) &lt; real(rhs);
        }
    }
}

<span class="co">// ベクタの長さ</span>
<span class="dt">double</span> vector_length(point a){
    <span class="kw">return</span> abs(a);
}

<span class="co">// 二点間距離</span>
<span class="dt">double</span> point_distance(point a,point b){
    <span class="kw">return</span> abs(a-b);
}

<span class="co">// 単位ベクトル</span>
point unit_vector(point a){
    <span class="kw">return</span> a / abs(a);
}

<span class="co">// 法線ベクトル</span>
pair&lt;point,point&gt; normal_vector(point a){
    point n1 = a * point(<span class="dv">0</span>,<span class="dv">1</span>);
    point n2 = a * point(<span class="dv">0</span>,-<span class="dv">1</span>);
    <span class="kw">return</span> make_pair(n1,n2);
}

<span class="co">// 点が一緒かどうか</span>
<span class="dt">bool</span> point_eq(point a,point b){
    <span class="kw">return</span> abs(a-b) &lt; EPS;
}
<span class="co">// 内積 (dot product) : a・b = |a||b|cosΘ</span>
<span class="dt">double</span> dot(point a,point b){
    <span class="kw">return</span> real(conj(a)*b);
}

<span class="co">// 外積 (cross product) : |a×b| = |a||b|sinΘ</span>
<span class="dt">double</span> cross(point a,point b){
    <span class="kw">return</span> imag(conj(a)*b);
}

<span class="co">// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定</span>
<span class="dt">bool</span> is_intersected_linesegment(point a1,point a2,point b1,point b2){
    <span class="kw">if</span>(max(a1.real(),a2.real()) + EPS &lt; min(b1.real(),b2.real())) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span>(max(b1.real(),b2.real()) + EPS &lt; min(a1.real(),a2.real())) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span>(max(a1.imag(),a2.imag()) + EPS &lt; min(b1.imag(),b2.imag())) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span>(max(b1.imag(),b2.imag()) + EPS &lt; min(a1.imag(),a2.imag())) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) &lt; EPS) <span class="kw">and</span>
           (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) &lt; EPS);

}


<span class="co">// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算</span>
point intersection_point_linesegment(point a1,point a2,point b1,point b2) {
    <span class="kw">if</span>(a1 == b1 <span class="kw">or</span> a1 == b2) <span class="kw">return</span> a1;
    <span class="kw">if</span>(a2 == b1 <span class="kw">or</span> a2 == b2) <span class="kw">return</span> a2;
    point b = b2-b1;
    <span class="dt">double</span> d1 = abs(cross(b, a1-b1));
    <span class="dt">double</span> d2 = abs(cross(b, a2-b1));
    <span class="dt">double</span> t = d1 / (d1 + d2);
    <span class="kw">return</span> a1 + (a2-a1) * t;
}

<span class="co">// 線分同士の最短距離</span>
<span class="dt">double</span> dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){
    <span class="kw">if</span>(is_intersected_linesegment(a1,a2,b1,b2)){
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    <span class="kw">return</span> min(min(dist_linesegment_and_point(a1,a2,b1),
               dist_linesegment_and_point(a1,a2,b2)),
           min(dist_linesegment_and_point(b1,b2,a1),
               dist_linesegment_and_point(b1,b2,a2)));
}


<span class="co">// 2直線の直交判定 : a⊥b &lt;=&gt; dot(a, b) = 0</span>
<span class="co">// みけんしょう</span>
<span class="dt">bool</span> is_orthogonal(point a1,point a2,point b1,point b2) {
    <span class="kw">return</span> dot(a1-a2,b1-b2) &lt; EPS;
}

<span class="co">// 2直線の平行判定 : a//b &lt;=&gt; cross(a, b) = 0</span>
<span class="dt">bool</span> is_parallel(point a1,point a2,point b1,point b2) {
    <span class="kw">return</span> abs(cross(a2-a1,b2-b1)) &lt; EPS;
}

<span class="co">// a1,a2を通る直線とb1,b2を通る直線の交差判定</span>
<span class="dt">bool</span> is_intersected_line(point a1,point a2,point b1,point b2) {
    <span class="kw">return</span> <span class="kw">not</span> is_parallel(a1,a2,b1,b2);
}

<span class="co">// a1,a2を通る直線とb1,b2を通る直線の交点計算</span>
point intersection_line(point a1,point a2,point b1,point b2) {
    point a = a2 - a1,b = b2 - b1;
    <span class="kw">return</span> a1 + a * cross(b, b1-a1) / cross(b, a);
}

<span class="co">// 直線と点との距離</span>
<span class="dt">double</span> dist_line_and_point(point a1,point a2,point b){
    <span class="kw">return</span> abs(cross(a2-a1,b-a1)) / abs(a2-a1);
}

<span class="co">// 線分と点との距離</span>
<span class="dt">double</span> dist_linesegment_and_point(point a1,point a2,point b){
    <span class="kw">if</span>(dot(a2-a1,b-a1) &lt; EPS) <span class="kw">return</span> abs(b-a1);
    <span class="kw">if</span>(dot(a1-a2,b-a2) &lt; EPS) <span class="kw">return</span> abs(b-a2);
    <span class="kw">return</span> dist_line_and_point(a1,a2,b);
}

<span class="co">// 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)</span>
point nearest_point_line_and_point(point a1,point a2,point b){
    <span class="kw">return</span> a1 + (a2-a1) * dot((a2-a1),(b-a1)) / norm(a2-a1);
}

<span class="co">// 線分と点の最短距離を実現する線分嬢の点(みけんしょう)</span>
point nearest_point_linesegment_and_point(point a1,point a2,point b){
    <span class="kw">if</span>(dot(a2-a1,b-a1) &lt; EPS) <span class="kw">return</span> a1;
    <span class="kw">if</span>(dot(a1-a2,b-a2) &lt; EPS) <span class="kw">return</span> a2;
    <span class="kw">return</span> nearest_point_line_and_point(a1,a2,b);
}
<span class="co">// 円と線分の交差判定</span>
<span class="dt">bool</span> is_cross_linesegment_and_circle(point c,<span class="dt">double</span> r,point a1,point a2){
    <span class="kw">return</span> (dist_linesegment_and_point(a1,a2,c) &lt; r+EPS <span class="kw">and</span>
             (r &lt; abs(c-a1) + EPS <span class="kw">or</span> r &lt; abs(c-a2) + EPS));
}


<span class="co">// 点の進行方向</span>
<span class="dt">int</span> ccw(point a,point b,point c){
    b -= a;c -= a;
    <span class="kw">if</span>(cross(b,c) &gt; <span class="dv">0</span>) <span class="kw">return</span> +<span class="dv">1</span>;    <span class="co">// counter clockwise</span>
    <span class="kw">if</span>(cross(b,c) &lt; <span class="dv">0</span>) <span class="kw">return</span> -<span class="dv">1</span>;    <span class="co">// clockwise</span>
    <span class="kw">if</span>(dot(b,c) &lt; <span class="dv">0</span>) <span class="kw">return</span> +<span class="dv">2</span>;      <span class="co">// c -- a -- b</span>
    <span class="kw">if</span>(norm(b) &lt; norm(c)) <span class="kw">return</span> -<span class="dv">2</span>; <span class="co">// a -- b -- c</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">// 点が真に多角形の中にはいっているか</span>
<span class="dt">bool</span> is_inner_point_vertex(vector&lt;point&gt; ps,point a){
    <span class="dt">int</span> cc = ccw(ps[<span class="dv">0</span>],ps[<span class="dv">1</span>],a);
    <span class="kw">if</span>(<span class="kw">not</span>(cc == <span class="dv">1</span> <span class="kw">or</span> cc == -<span class="dv">1</span>)) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;ps.size();i++){
        <span class="kw">if</span>(cc != ccw(ps[i],ps[(i<span class="dv">+1</span>)%ps.size()],a)) <span class="kw">return</span> <span class="kw">false</span>;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// 点が辺上、もしくは内部にある。(未検証)</span>
<span class="dt">bool</span> is_inner_point_vertex_or_line(vector&lt;point&gt; ps,point a){
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;ps.size();i++){
        <span class="kw">if</span>(ccw(ps[i],ps[(i<span class="dv">+1</span>)%ps.size()],a) == +<span class="dv">2</span> <span class="kw">or</span>
           abs(ps[i]-a) &lt; EPS ){
            <span class="kw">return</span> <span class="kw">true</span>;
        }
    }
    <span class="dt">int</span> cc = ccw(ps[<span class="dv">0</span>],ps[<span class="dv">1</span>],a);
    <span class="kw">if</span>(<span class="kw">not</span>(cc == <span class="dv">1</span> <span class="kw">or</span> cc == -<span class="dv">1</span>)) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;ps.size();i++){
        <span class="kw">if</span>(cc != ccw(ps[i],ps[(i<span class="dv">+1</span>)%ps.size()],a)) <span class="kw">return</span> <span class="kw">false</span>;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="co">// 凸包 (UVA 109)</span>
vector&lt;point&gt; convex_hull(vector&lt;point&gt; ps){
    <span class="dt">int</span> n = ps.size();
    <span class="dt">int</span> k = <span class="dv">0</span>;
    sort(ps.begin(),ps.end());
    vector&lt;point&gt; ch(<span class="dv">2</span>*n);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;ch[k++] = ps[i++]){
        <span class="kw">while</span>(k &gt;= <span class="dv">2</span> <span class="kw">and</span> ccw(ch[k<span class="dv">-2</span>],ch[k<span class="dv">-1</span>],ps[i]) &lt;= <span class="dv">0</span>) --k;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=n<span class="dv">-2</span>,t=k<span class="dv">+1</span>;i&gt;=<span class="dv">0</span>;ch[k++]=ps[i--]){
        <span class="kw">while</span>(k &gt;= t <span class="kw">and</span> ccw(ch[k<span class="dv">-2</span>],ch[k<span class="dv">-1</span>],ps[i]) &lt;= <span class="dv">0</span>) --k;
    }
    ch.resize(k<span class="dv">-1</span>);
    <span class="kw">return</span> ch;
}

<span class="co">// 円と円の交点(2点ある前提)</span>
vector&lt;point&gt; circles_point(point c1,<span class="dt">double</span> r1,point c2,<span class="dt">double</span> r2){
    <span class="dt">double</span> d = abs(c1-c2);
    <span class="dt">double</span> s = (r1+r2+d) / <span class="dv">2</span>;
    <span class="dt">double</span> S = sqrt(s*(s-r1)*(s-r2)*(s-d));
    <span class="dt">double</span> h = <span class="dv">2</span> * S / d;
    point v = (c2-c1) / (abs(c2-c1));

    <span class="dt">double</span> m = sqrt(r1*r1 - h*h);

    vector&lt;point&gt; ret;
    ret.push_back(c1 + m*v+h*v*point(<span class="dv">0</span>,<span class="dv">1</span>));
    ret.push_back(c1 + m*v-h*v*point(<span class="dv">0</span>,<span class="dv">1</span>));
    <span class="kw">return</span> ret;
}

<span class="co">// clockwiseだと負</span>
<span class="dt">double</span> triangle_area(point a,point b,point c){
    <span class="kw">return</span> cross(b-a,c-a)/<span class="dv">2</span>;
}

<span class="co">// clockwiseだと負</span>
<span class="dt">double</span> vertex_area(vector&lt;point&gt; v){
    <span class="dt">double</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;v.size()-<span class="dv">1</span>;i++){
        ret += triangle_area(v[<span class="dv">0</span>],v[i],v[i<span class="dv">+1</span>]);
    }
    <span class="kw">return</span> ret;
}</code></pre>
<h1 id="ゲーム"><a href="#ゲーム"><span class="header-section-number">13</span> ゲーム</a></h1>
<h2 id="nim"><a href="#nim"><span class="header-section-number">13.1</span> Nim</a></h2>
<p>いくつかのコインの山がある。この中からプレイヤーは山を一つ選び、1個以上の任意の 数のコインを取る。最後のコインを取ったプレイヤーが勝ちである。この問題に 対しては以下のことが知られている。すべての山のxorをとったとき、それが0で あるとき、後攻の勝ち、それ以外のときは先攻の勝ち。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main(){
    <span class="dt">int</span> xor_sum = <span class="dv">0</span>;
    vector&lt;<span class="dt">int</span>&gt; coins = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>};
    <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;coins.size();i++){
        xor_sum = xor_sum ^ coins[i];
    }
    <span class="kw">if</span>(xor_sum != <span class="dv">0</span>) cout &lt;&lt; <span class="st">&quot;First Player Win&quot;</span> &lt;&lt; endl;
    <span class="kw">else</span> cout &lt;&lt; <span class="st">&quot;Second Player Win&quot;</span> &lt;&lt; endl;
}</code></pre>
<h1 id="いろんなデータ"><a href="#いろんなデータ"><span class="header-section-number">14</span> いろんなデータ</a></h1>
<h2 id="階乗"><a href="#階乗"><span class="header-section-number">14.1</span> 階乗</a></h2>
<table>
<thead>
<tr class="header">
<th align="left"><span class="math">\(N\)</span></th>
<th align="left"><span class="math">\(N!\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">6</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">24</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">120</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">720</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">5040</td>
</tr>
<tr class="odd">
<td align="left">8</td>
<td align="left">40320</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="left">362880</td>
</tr>
<tr class="odd">
<td align="left">10</td>
<td align="left">3628800</td>
</tr>
</tbody>
</table>
<h2 id="数単位変換"><a href="#数単位変換"><span class="header-section-number">14.2</span> 数単位変換</a></h2>
<table>
<thead>
<tr class="header">
<th align="left">N</th>
<th align="left">日本語</th>
<th align="center">英語</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math">\(10^{0}\)</span></td>
<td align="left">一</td>
<td align="center">one</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(10^{1}\)</span></td>
<td align="left">十</td>
<td align="center">ten</td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(10^{2}\)</span></td>
<td align="left">百</td>
<td align="center">hundred</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(10^{3}\)</span></td>
<td align="left">千</td>
<td align="center">thousand</td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(10^{4}\)</span></td>
<td align="left">万</td>
<td align="center">ten thousand</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(10^{5}\)</span></td>
<td align="left">十万</td>
<td align="center">hundred thousand</td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(10^{6}\)</span></td>
<td align="left">百万</td>
<td align="center">million</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(10^{7}\)</span></td>
<td align="left">千万</td>
<td align="center">ten million</td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(10^{8}\)</span></td>
<td align="left">億</td>
<td align="center">hundred million</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(10^{9}\)</span></td>
<td align="left">十億</td>
<td align="center">billion</td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(10^{10}\)</span></td>
<td align="left">百億</td>
<td align="center">ten billion</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(10^{11}\)</span></td>
<td align="left">千億</td>
<td align="center">hundred billion</td>
</tr>
</tbody>
</table>
<h2 id="bit"><a href="#bit"><span class="header-section-number">14.3</span> bit</a></h2>
<table>
<thead>
<tr class="header">
<th align="left">N</th>
<th align="left"><span class="math">\(2^N\)</span></th>
<th align="left">備考</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">2</td>
<td align="left">boolの大きさ</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">16</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">128</td>
<td align="left">charの最大値+1</td>
</tr>
<tr class="odd">
<td align="left">8</td>
<td align="left">256</td>
<td align="left">unsigned charの最大値+1</td>
</tr>
<tr class="even">
<td align="left">16</td>
<td align="left">65,534</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">24</td>
<td align="left">16,777,216</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">31</td>
<td align="left">2,147,483,648</td>
<td align="left">intの最大値+1(about 2*10^9)</td>
</tr>
<tr class="odd">
<td align="left">32</td>
<td align="left">4,294,967,296</td>
<td align="left">unsigned intの最大値+1</td>
</tr>
<tr class="even">
<td align="left">52</td>
<td align="left">4,503,599,627,370,496</td>
<td align="left">doubleのprecision</td>
</tr>
<tr class="odd">
<td align="left">63</td>
<td align="left">9,223,372,036,854,775,808</td>
<td align="left">long longの最大値+1</td>
</tr>
<tr class="even">
<td align="left">64</td>
<td align="left">18,446,744,073,709,551,616</td>
<td align="left">unsigned long longの最大値+1(about 10^19)</td>
</tr>
</tbody>
</table>
<h2 id="最低限の設定ファイル"><a href="#最低限の設定ファイル"><span class="header-section-number">14.4</span> 最低限の設定ファイル</a></h2>
<h3 id="vim用"><a href="#vim用"><span class="header-section-number">14.4.1</span> vim用</a></h3>
<p>最低限のもの。ホームにおく。</p>
<pre><code>set fileencoding=utf-8
set nocompatible
set t_Co=256
set ambiwidth=double

syntax on
filetype plugin indent on

set nobackup
set noswapfile

set completeopt=menuone
set wildmode=list:longest

set smartindent
set autoindent
set tabstop=4
set softtabstop=4
set shiftwidth=4

set smarttab
set expandtab

set incsearch ignorecase hlsearch
set showmatch
set wildmenu

set listchars=tab:&gt;-,trail:-
set list

set backspace=indent,eol,start</code></pre>
<!-- 
## アスキーコード


Char   Dec    Oct    Hex
------ ------ ------ ------
(nul)    0     0000   0x00
(soh)    1     0001   0x01
(stx)    2     0002   0x02
(etx)    3     0003   0x03
(eot)    4     0004   0x04
(enq)    5     0005   0x05
(ack)    6     0006   0x06
(bel)    7     0007   0x07
(bs)     8     0010   0x08
(ht)     9     0011   0x09
(nl)    10     0012   0x0a
(vt)    11     0013   0x0b
(np)    12     0014   0x0c
(cr)    13     0015   0x0d
(so)    14     0016   0x0e
(si)    15     0017   0x0f
(dle)   16     0020   0x10
(dc1)   17     0021   0x11
(dc2)   18     0022   0x12
(dc3)   19     0023   0x13
(dc4)   20     0024   0x14
(nak)   21     0025   0x15
(syn)   22     0026   0x16
(etb)   23     0027   0x17
(can)   24     0030   0x18
(em)    25     0031   0x19
(sub)   26     0032   0x1a
(esc)   27     0033   0x1b
(fs)    28     0034   0x1c
(gs)    29     0035   0x1d
(rs)    30     0036   0x1e
(us)    31     0037   0x1f
(sp)    32     0040   0x20
!       33     0041   0x21
"       34     0042   0x22
#       35     0043   0x23
$       36     0044   0x24
%       37     0045   0x25
&       38     0046   0x26
'       39     0047   0x27
(       40     0050   0x28
)       41     0051   0x29
*       42     0052   0x2a
+       43     0053   0x2b
,       44     0054   0x2c
-       45     0055   0x2d
.       46     0056   0x2e
/       47     0057   0x2f
0       48     0060   0x30
1       49     0061   0x31
2       50     0062   0x32
3       51     0063   0x33
4       52     0064   0x34
5       53     0065   0x35
6       54     0066   0x36
7       55     0067   0x37
8       56     0070   0x38
9       57     0071   0x39
:       58     0072   0x3a
;       59     0073   0x3b
<       60     0074   0x3c
=       61     0075   0x3d
>       62     0076   0x3e
?       63     0077   0x3f
@       64     0100   0x40
A       65     0101   0x41
B       66     0102   0x42
C       67     0103   0x43
D       68     0104   0x44
E       69     0105   0x45
F       70     0106   0x46
G       71     0107   0x47
H       72     0110   0x48
I       73     0111   0x49
J       74     0112   0x4a
K       75     0113   0x4b
L       76     0114   0x4c
M       77     0115   0x4d
N       78     0116   0x4e
O       79     0117   0x4f
P       80     0120   0x50
Q       81     0121   0x51
R       82     0122   0x52
S       83     0123   0x53
T       84     0124   0x54
U       85     0125   0x55
V       86     0126   0x56
W       87     0127   0x57
X       88     0130   0x58
Y       89     0131   0x59
Z       90     0132   0x5a
[       91     0133   0x5b
\       92     0134   0x5c
]       93     0135   0x5d
^       94     0136   0x5e
_       95     0137   0x5f
`       96     0140   0x60
a       97     0141   0x61
b       98     0142   0x62
c       99     0143   0x63
d      100     0144   0x64
e      101     0145   0x65
f      102     0146   0x66
g      103     0147   0x67
h      104     0150   0x68
i      105     0151   0x69
j      106     0152   0x6a
k      107     0153   0x6b
l      108     0154   0x6c
m      109     0155   0x6d
n      110     0156   0x6e
o      111     0157   0x6f
p      112     0160   0x70
q      113     0161   0x71
r      114     0162   0x72
s      115     0163   0x73
t      116     0164   0x74
u      117     0165   0x75
v      118     0166   0x76
w      119     0167   0x77
x      120     0170   0x78
y      121     0171   0x79
z      122     0172   0x7a
{      123     0173   0x7b
|      124     0174   0x7c
}      125     0175   0x7d
~      126     0176   0x7e
(del)  127     0177   0x7f
-->
</body>
</html>
